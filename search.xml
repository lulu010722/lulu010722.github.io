<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JPA事务控制与外键死锁</title>
    <url>/jpa%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%A4%96%E9%94%AE%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<h1 id="问题背景">问题背景</h1>
<p>在做app作业一的第二部分时，遇到了问题（自以为是问题，没想到老师是故意让我们发现这是个bug）。</p>
<pre class="mermaid">flowchart LR;
A(OrderController::createOrder) --> B(OrderService::createOrder);
B --> C(OrderDao::addOne);
B --> D(OrderItemDao::addList);</pre>
<p>如图，在电子书服务系统<code>E-Book</code>中，我们进行订单创建，一个订单<code>order</code>中包含多个订单项<code>orderItem</code>。</p>
<p>现在我们要对<code>OrderService::createOrder</code>，<code>OrderDao::saveOne</code>和<code>OrderItemDao::saveList</code>进行事务传播控制，分别简称三部分为A，B，C。</p>
<p>若A和B设置为<code>REQUIRED</code>，而C设置为<code>REQUIRES_NEW</code>，则会出现死锁问题。</p>
<p>源代码大致如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OrderServiceImpl.java</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(List&lt;Integer&gt; bookIds, Long userId)</span> &#123;</span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setUser(userDao.findOne(userId));</span><br><span class="line">    orderDao.addOne(order);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备orderItems的List</span></span><br><span class="line">    List&lt;OrderItem&gt; orderItems = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ...;</span><br><span class="line">    </span><br><span class="line">    orderItemDao.addList(orderItems);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderDaoImpl.java</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">    orderRepository.save(order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderItemDaoImpl.java</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addList</span><span class="params">(List&lt;OrderItem&gt; orderItems)</span> &#123;</span><br><span class="line">    orderItemRepository.saveList(orderItems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果为死锁。</p>
<p><br></p>
<h1 id="原因分析">原因分析</h1>
<p>在B执行后，由于与A处在同一事务一里，则事务一拿到了<code>order</code>表中新插入行的锁，不管事务隔离属性如何设置，其他事务均不可进行写操作。而在随后的C流程中，写入<code>orderItems</code>的时候，<code>order_item</code>表中有<code>order</code>的外键，于是他在给<code>order_item</code>新插入的数据上锁之外，也要在<code>order</code>表中对外键所指向的数据加锁。</p>
<p>然而C是拿不到的，因为B已经拿到了。</p>
<p>于是此时，C等待B放锁，但是同时，B又等待C结束返回，从而形成了死锁。</p>
<p><br></p>
<h1 id="解决方法">解决方法</h1>
<p>该问题说明，并不是所有业务使用<code>REQUIRES_NEW</code>传播都可以，在此场景下，都使用默认的<code>REQUIRED</code>传播属性即可。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>cse-lab2a踩坑</title>
    <url>/cse-lab2a%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<ol type="1">
<li><p><code>ifstream::eof()</code>有bug。</p>
<p>如果有一个文件<code>test.txt</code>，文件内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 a</span><br><span class="line">2 ab</span><br><span class="line">3 abc</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（注意，最后有一个空行）</p>
<p>则，当时用下面的代码时，会有问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!in.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">       	<span class="type">int</span> length;</span><br><span class="line">        in &gt;&gt; length;</span><br><span class="line">        <span class="type">char</span> tmp[length + <span class="number">1</span>];</span><br><span class="line">        in.<span class="built_in">read</span>(tmp, length);</span><br><span class="line">        cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因在于，第三行读取完成后，不管是否将最后的换行符进行了消除，<code>eof()</code>会仍然返回false，因为只有当读到最后一个字符并尝试继续读的时候，该函数才会返回true。</p></li>
</ol>
]]></content>
      <categories>
        <category>cse</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>cse-lab1踩坑</title>
    <url>/cse-lab1%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<ol type="1">
<li>memcpy与strncpy。</li>
<li>get_inode需要在堆中分配内存。</li>
<li>局部字符数组最好初始化为0。</li>
<li>ino的block不要随便free，有可能free掉别人的合法block。</li>
</ol>
]]></content>
      <categories>
        <category>cse</category>
      </categories>
      <tags>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>git——人类好朋友</title>
    <url>/git%E2%80%94%E2%80%94%E4%BA%BA%E7%B1%BB%E5%A5%BD%E6%9C%8B%E5%8F%8B/</url>
    <content><![CDATA[<h1 id="本地远程分支创建和删除">本地/远程分支创建和删除</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地分支</span></span><br><span class="line">git branch -d &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程分支</span></span><br><span class="line">git push -d &lt;remote-name&gt; &lt;branch-name&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除已经不存在于远程仓库的本地远程分支</span></span><br><span class="line">git remote prune &lt;remote-name&gt;</span><br></pre></td></tr></table></figure>
<h1 id="git-submodule初步运用">git submodule初步运用</h1>
<p>实际场景：在博客主仓库中日常更新日志内容的同时，想要对主题仓库进行个性化修改，或者更进一步，对原主题仓库提出PR，进行contribute。主仓库需要拥有子仓库的文件内容，因为前者要根据后者的资源进行页面的渲染。</p>
<p>这样，我们就需要在主仓库（blog）中包含子仓库（themes）。为了更方便地管理他们，需要使用git
submodule。</p>
<h2 id="原来的做法">原来的做法</h2>
<p>将themes.git文件夹删除，使其失去版本控制，并将themes（.gitignore的除外）加入主仓库的版本控制。在本地的修改可以直接更新到主仓库，在github直接执行npm
run build的CI任务即可。</p>
<p><strong>但是</strong>，这样有很多问题。</p>
<ol type="1">
<li>如果遇到明显的bug，只能在本地修改，无法对原主题仓库进行贡献。</li>
<li>原主题仓库更新后，本地无法通过git快捷的更新。</li>
</ol>
<h2 id="使用git-submodule">使用git submodule</h2>
<p>git对于子模块的管理有如下几个关键点。</p>
<ul>
<li>首先，.git目录中会有一个modules目录，里面记录了所有子模块的版本控制信息。</li>
<li>其次，在主仓库下，会创建一个.gitmodules文件，里面以条目的形式记录了子仓库名称，本地相对地址，以及远程仓库地址。</li>
<li>最后，git会生成一个<strong>非常特殊</strong>的文件，他的文件模式是160000，与一般的100644文件不同。它在windows的资源管理器下并不可见。他被用于覆盖子模块真实的目录内容，仅仅以子模块的当前所在记录的hash值，存入该文件来代替。每当子模块更新，该文件也会更新。</li>
</ul>
<p>创建流程是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果是第一次创建子模块，则项目中会出现两个新文件：.gitmodules和以relative-path为名的特殊文件。同时，该命令会将子模块克隆到本地的relative-path目录下。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git submodule add &lt;url(https://github.com/username/submodule-repo.git)&gt; &lt;relative-path&gt;</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在主仓库，将更改提交并push到远程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add --all</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m &lt;msg&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br></pre></td></tr></table></figure>
<p>此时，在主仓库中，relative-path对应的地方会出现一个链接，点击可以跳转到子模块的仓库。</p>
<p>这就意味着，主仓库是没有子仓库的内容的，只保留了一个链接。</p>
<p>想要获得子模块的内容，需要在workflow file里面加入新的CI任务。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意，该任务需要放在build之前</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Fetch</span> <span class="string">submodule</span></span><br><span class="line"><span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">	<span class="string">git</span> <span class="string">submodule</span> <span class="string">sync</span></span><br><span class="line">	<span class="string">git</span> <span class="string">submodule</span> <span class="string">update</span> <span class="string">--init</span> <span class="string">--recursive</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，主仓库会获得子仓库的内容，并根据子仓库的内容build博客。</p>
<h2 id="权限问题">权限问题</h2>
<p>如果使用了ssh的仓库地址，则可能会出现权限问题。</p>
<p>由于我的子仓库是公有仓库，所以简单的解决办法是，使用https的仓库地址。</p>
<h2 id="与github-actionscheckoutv3集成">与github
actions/checkout@v3集成</h2>
<p>github仓库服务器每次运行CI/CD任务，其实都需要将主仓库克隆到本地。这是通过复用<code>actions/checkout@v3</code>实现的。而该action同时提供了对子模块的支持。只需要进行如下配置即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">submodules:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>该配置还能自动在没有提供ssh-key的情况下，将<code>.gitmodules</code>中由ssh协议指定的url转换成https来使用。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>高级操作</tag>
      </tags>
  </entry>
  <entry>
    <title>inode文件系统</title>
    <url>/inode%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="层架构">7层架构</h1>
<h2 id="block-layer">Block Layer</h2>
<p>将block的序数，映射到block中实际的数据。</p>
<p><strong>块大小的权衡</strong></p>
<p>太小，则bitmap所需空间太大。</p>
<p>太大，则内部浪费可能比较严重。</p>
<p><br></p>
<h2 id="file-layer">File Layer</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct inode</span><br><span class="line">	integer block_nums[N]</span><br><span class="line">	integer size</span><br></pre></td></tr></table></figure>
<p>N决定了一个文件最大有多大。</p>
<p>与块大小的权衡一样，N的大小也存在权衡。</p>
<p><strong>解决措施</strong>：多级inode。</p>
<p>inode的block_nums中的元素可以指向另外一个inode，类似于多级页表。</p>
<p>个人理解，在block层上又封装了一层inode的原因，就是因为inode可以做多级操作，否则就和block相同了，区别仅仅是更大。</p>
<p><br></p>
<h2 id="inode-number-layer">Inode Number Layer</h2>
<p>将inode放在一张表里，这样可以通过index来访问某一inode。</p>
<p><br></p>
<h2 id="file-name-layer">File Name Layer</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct inode</span><br><span class="line">	integer block_nums[N]</span><br><span class="line">	integer size</span><br><span class="line">	integer type // 记录inode类型，包含常规文件，目录，和符号链接等等</span><br></pre></td></tr></table></figure>
<h2 id="path-name-layer">Path Name Layer</h2>
<p>链接link。</p>
<p>可以将多个文件名映射到同一个inode。</p>
<p>除了.和..，不允许对目录进行链接，否则可能会出现“外存泄露”。</p>
<p><strong>重命名-1</strong></p>
<ol type="1">
<li>UNLINK(to_name)</li>
<li>LINK(from_name, to_name)</li>
<li>UNLINK(from_name)</li>
</ol>
<p>但是这种实现有问题，当1和2之前出现了failure时，to_name没了，但是from_name还在。</p>
<p><strong>重命名-2</strong></p>
<ol type="1">
<li>LINK(from_name, to_name)</li>
<li>UNLINK(from_name)</li>
</ol>
<p><br></p>
<h2 id="absolute-path-name-layer">Absolute Path Name Layer</h2>
<p>根目录/。其.和..都指向/。</p>
<p><br></p>
<h2 id="symbolic-link-layer">Symbolic Link Layer</h2>
<p>跨存储设备。</p>
<p>通过文件名进行链接。</p>
<p>其大小指的是文件名字符串长度。</p>
<p><strong>问题</strong>：如果通过symbolic link进入了一个目录，再运行cd
..，则会进入哪个目录？</p>
<p><strong>答案</strong>：会进入原目录，而不是实际目录的上层目录。</p>
<p>因为cd ..会被bash先解析，这是一种优化。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>cse</tag>
      </tags>
  </entry>
  <entry>
    <title>《月亮与六便士》</title>
    <url>/%E3%80%8A%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB%E3%80%8B/</url>
    <content><![CDATA[<blockquote>
<p>满地都是六便士，他却抬头看见了月亮。</p>
</blockquote>
<p>其实，上面这句话，并非出自原书。起初是对毛姆的《人性的弱点》的匿名评论，被刘瑜概括成了这句话。毛姆很喜欢月亮和六便士的比喻，便以此为题，开始进行他下一篇长篇小说的创作。</p>
<p><img src="/images/liubianshi.png" /></p>
<p>思特里克兰德是一个极为勇敢的天才，同时也是一个人性的罪犯。</p>
<p>故事开篇，他已然是一个小有成就的股票经纪人，有一个漂亮贤惠的妻子，和一对健康活泼的儿女。但是，一个人的处境越安逸，越稳定，想要跳出这种枷锁，便越需要非凡的勇气。当思特里克兰德决定去往巴黎，再也不回来的时候，那给读者的感觉，是多种情感的复合。是费解，是好奇，是愤怒，同时也在读者心中悄然树立他非凡的形象。</p>
<p>他来到巴黎，本就不富裕的生活，很快就变得更加落魄。此时，施特略夫对他的帮助，是不被理解的，甚至是有违常理的。施特略夫是这本书里一个悲剧人物，笔者从他的身上看到了自己的影子。他是一个一味讨好的人，是一个无法拒绝别人的人，甚至是没有尊严的人。毛姆笔下的“我”，对它的态度是同情，而又轻蔑。</p>
<p>没有底线地付出自己的好，会把一个人变得低价值，而低价值的人所展现出的善良，又经常会被践踏。这是人性的弱点，有些人会下意识地慕强，对于低价值的人，他们唯恐避之不及。另一方面，只有低价值的人，才会无限制地对别人好。他无法通过自己的外在的或内在的魅力吸引他人，所以只能通过一些廉价的讨好，来维持与他人的关系，无论是爱情，友情还是社交。这些人被亲近的人用“善良“夸赞，殊不知那恰恰不是真心的善良，而是一种软弱。这听起来或许很残酷，可是，可怜之人必有可恨之处。他们在讨好别人的简单模式，和提升自己的困难模式之中，选择了前者，来维持一些肤浅的，一碰就碎的关系，可谓是舍本逐末。施特略夫惹人同情，可是，对于他自己的悲剧，我认为他不无责任。他那近乎无耻的善意，虽然拯救了思特里克兰德的生命，但是仍然遭人唾弃，这就是人性。</p>
<p>害死了布兰特，伤透了施特略夫，在被问及，“你是否对这些事，曾经抱有过一点内疚的情感？”时，思特里克兰德的回答是，“我为什么要内疚？”他丝毫不受影响，即使他的身上，已经搭上了一条人命。他的冷漠深入骨髓，任何道德或伦理，在他这里无法奏效。他作为一个人，是一个道德的罪犯，然而他确实是一个真正自由的人。</p>
<p>他在马赛的生活我认为可以忽略，仅仅以艰难困苦代替即可。</p>
<p>在塔希提岛，他真正找到了自己一直寻找的心灵归处。他找到了一个真正爱他的女人，他又有了几个孩子，虽然这些对他而言，轻如鸿毛。他开始在山中一间偏僻又简陋的屋子里，开始自己的创作。上帝首先是夺走了他的眼睛，然而这无法阻止他沉浸在那个涂满壁画的屋子里，直到他被夺去了生命，连同他那惊世骇俗的壁画屋一起。</p>
<p><br></p>
<p>多看了几篇他人的书评，仔细琢磨了书中的次要人物，也有新发现。</p>
<p>思特里克兰德太太是一个精明有城府的人，他善于伪装自己，即使她的丈夫早已抛弃他二十余年，她还是对外人维持着一种平安无事的假象。书中有这样一段话：</p>
<blockquote>
<p>在她破碎的心中，爱情受辱的苦闷是否掺杂着虚荣心受损的痛苦，这在年轻的我看来是肮脏的，这种怀疑令我不安。</p>
</blockquote>
<p>她的悲伤是不单纯的，其中怀有对社会地位丧失，对自身颜面扫地的虚荣。</p>
<p>而布兰特，她没有选择，幼年遭遇使她没有办法拒绝当时的施特略夫，从而嫁给了一个她不爱的男人。当听说丈夫要带思特里克兰德回家养病，她的恐惧，也许是害怕自己真的会压抑不住性的呼唤，做出有悖伦理的事。这在当时的英国社会，是饱受唾弃的。</p>
<p><br></p>
<p>本想补充些什么，终于想不出，便放些名句摘抄不妨。</p>
<blockquote>
<p>她这么说毫无贬低之意，反倒充满深情，她好像希望通过承认他最差的一面，来保护他免受朋友诽谤。</p>
</blockquote>
<blockquote>
<p>愤怒的道德没有足够的力量对罪人直接加以惩罚，这总是令人痛心的。</p>
</blockquote>
<blockquote>
<p>我不知真诚中有多少伪装，高贵中有多少卑鄙，邪恶中有多少善良。</p>
</blockquote>
<blockquote>
<p>一个人掉进水里，游泳游得好坏都无关紧要，他必须出去，否则就会淹死。</p>
</blockquote>
<blockquote>
<p>只有诗人或圣徒才会自信地期望，浇灌沥青路面，百合花会回报他的辛劳。</p>
</blockquote>
<blockquote>
<p>当人们说他们不在乎别人怎么看他们时，他们多半是在欺骗自己。</p>
<p>当你的非常规只是你那个群体的常规时，做到世人眼中的非常规并不难。</p>
</blockquote>
<blockquote>
<p>她很精明地意识到，你老是诉说不幸，人们很快就会厌倦，而且不愿看到你的惨样。</p>
</blockquote>
<blockquote>
<p>女人经常为了爱情寻短见，但一般来说，她们会很小心，不会让自杀成功。</p>
</blockquote>
<blockquote>
<p>女人可以原谅他对她造成的伤害，却永远无法原谅他为她做出的牺牲。</p>
</blockquote>
<blockquote>
<p>自命不凡只会暴露他的思想贫乏。涂了油漆貌似铁板的木条看上去也只是木条。</p>
</blockquote>
]]></content>
      <categories>
        <category>书架</category>
      </categories>
      <tags>
        <tag>月亮与六便士</tag>
      </tags>
  </entry>
  <entry>
    <title>ただいま</title>
    <url>/%E3%81%9F%E3%81%A0%E3%81%84%E3%81%BE/</url>
    <content><![CDATA[<h1 id="ロジちゃん">ロジちゃん</h1>
<p>ロジちゃんは既に家に帰ってきたね。無事で帰国しましたのは良かった!日本にいたこの半年間、交大よりもっとすばらしい世界を見たはずでしょう。各地の観光地に行ったり、自然風景を鑑賞したり、美しい日本式の建物を観覧したり、美味しい特色な美食を食べたりをするのには、僕はほんとに羨ましいな。でももちろん、一番大事なことは東大での勉強体験だ。</p>
<p>その一方で、こちらの生活は、いつもと同じに退屈でした。特に君を失ったあと、もっと退屈になっちゃった。以前に二人は一緒に歩いた場所や小道も、なんか突然死んだみたい実感が感じました。湖の周りにあるベンチには、いつも恋人たちがデートをする。しかしそのなかには、私達がいるわけがなくなった。</p>
<p>あぁ、覚えてきた。私はそのワイトアルバム2っていうゲイムをした。三人の物語をだいたいわかりました。言いたいのは、私はとある歌のなかに（歌名を忘れた）ひとつの歌詞に思い出ぶかいだ。何でしたっけ、「ずっとあなたの名前、何度も、何度も読んだ。夢の中のあなたも、振り返ることはない。」毎回聞くとすぐに泣きそうだ。でもせめて、春希は雪菜に少しの感情が残るんだ。しかし、私のロジちゃんは、永遠に私のことが嫌くなった。残念ですね。今残っているのは、嘆きしかないんだ。</p>
<p>ロジちゃん、私は君を愛してるほど憎んでいます。それは君は間もなくわかります。だから驚かないでね。</p>
<p>最後に、君は「私達は今生にはお夫婦になれなくて、来世も不可能です」って言ったはずだろう。じゃあ、ご要望のとおり、私は今から来世に死ぬまで、君を邪魔しないようにしましょう!しかし、もし来世というものがあったら、何故再来世があってはいけないの?あそこでまた待ち合わせるのも悪くないんじゃん?シシシ。私は先に失礼しますぞ!</p>
<p>では、また再来世。</p>
<p>最初から宇宙が終わるまで君をずうっと愛している憨憨</p>
<hr />
<h1 id="王氏の野郎">王氏の野郎</h1>
<p>貴様はもう東京から帰りましたんだろう。日本で飢え死にしなかったのは不思議なんですね。ぶち殺されなかったのもありえないんだね。でもそれはちょうどいい。以下の言葉をちゃんと読みなさい。</p>
<p>私はこの半年のあいだに、貴様をよく夢見てたよ。でも、夢の中で私達は何をしましたかのを知ってるかい?恐らくいいことではなかった。教えてあげよう。まず、貴様を誰もいない場所に連れて行って、死ぬまでレイプすること。また、貴様の顔に硫酸を撒くこと。貴様の自殺したい表情や涙を見るのは最高に快適だな!そして、爆弾を使って、両親と貴様を一緒に殺すこと。怖いですよねワァハーーーー。</p>
<p>忘れないでね、貴様は何の才能もないやつだ。以前はそうだったし、未来もそうになります。アァ、忘れてた、貴様の唯一の才能は、男に顔やおっぱいや膣を出すことしかないんだよ。信じないですか?では十年あとに振り返って見なさい。そのときに、あんたはこれはどれほど正しい判断でしたのを理解していく。</p>
<p>ずっと劣等感に落ち込んでた貴様は、ある人の影響で、どんどん自信が見つかたから、積極的に、そして社交を得意すぎる「牛膣病?」ようになりました。でも、貴様がそれは全く忘れた!何か「私達は性格が合わないから別れなければならない」っていう嘘を言って、その人を死んだネズミのように飛ばした。ホンマに偉かったね!すばらしいしか言えませんよ!</p>
<p>でも実際は、私は安心です。君は昔に最も親密な人に対してさえも、そんなに残酷なやり方で飛ばすことにしました。では次に、その次に、同じ結局でおしまいになっちゃうんだろう?ハハハーーー。</p>
<p>以上です。この王氏の野郎、永遠に会えないように!</p>
<p>別れた後から宇宙が終わるまで貴様をずうっと憎んでいる俺様</p>
]]></content>
      <categories>
        <category>信</category>
      </categories>
  </entry>
  <entry>
    <title>《苏东坡传》</title>
    <url>/%E3%80%8A%E8%8B%8F%E4%B8%9C%E5%9D%A1%E4%BC%A0%E3%80%8B/</url>
    <content><![CDATA[<blockquote>
<p>莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。</p>
<p>料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。</p>
</blockquote>
<p>走进林语堂先生的《苏东坡传》，东坡正传没见几句，倒是看了不少苏家长辈的趣事，还有三苏二次赴京上任途中的三峡奇景。林语堂先生的语言通俗易懂，偶尔诙谐幽默。例如，今日读到，苏洵青年时期不爱读书。直至27岁，看到自己的哥哥，内兄，还有两个姐丈，都已科考成功，行将做官为吏，顿时追悔韶光虚掷，痛自鞭策。对此，他这样写到：</p>
<blockquote>
<p>大人常举这件事来鼓励年轻人，告以只要勤勉奋发，终会成功的。当然，聪明的孩子也许会推演出相反的结论，那就是孩童之时不一定非要专心向学。</p>
</blockquote>
<p>又有另一处。书中讲到，古时行经三峡的人，往往在进入三峡之前焚香祷告，出了三峡再焚香谢神。于是：</p>
<blockquote>
<p>不管他们上行下行，在三峡危险的地方，神祇准保有美酒牛肉大快朵颐。</p>
</blockquote>
<p><br></p>
<p>多日未曾开卷，今天可终于是把苏东坡人生中最重要的一段政治经历——王安石变法——看完了。</p>
<p>诚如一众读者所感，我也觉得，在《苏传》中，他对于王安石的描摹未免有失偏颇。在这本书中，王安石被刻画成了一个颠倒黑白，混淆是非，党同伐异，欺君罔上的小人。自“王安石变法”至“人的恶行”凡三章，或明指王安石改革制度危害之深重，或暗喻王安石个人品行之败坏，不一而足。</p>
<p>虽未尝研读王安石的经史著作，亦不曾考究其变法内容的实际影响，可单单由王安石之被列入“唐宋八大家”一事便可知，他本人想必并不像林语堂笔下所写一般卑劣。林语堂受西方经济社会制度的影响，对王安石变法所代表的国家资本主义思想深恶痛绝，再加上此书又是为苏轼著书立说，于是在个人情感的影响下，将王安石描述的过于负面，有失公正，不够客观。</p>
<p>受此时局动荡之影响，苏东坡很难自保。他一向是坦率直言，为人最忌阳奉阴违。他对新政的看法基本中立，对王安石的变法内容不全盘否定，但也并不欣然接受，于是他在朝中，自然在两派中都无法交好。</p>
<p><br></p>
<p>熙宁四年（1071），苏轼来到杭州，他的第二故乡。对于杭州人来说，他们是不喜欢承认苏东坡生于眉州的，原文如下：</p>
<blockquote>
<p>今天，去此伟大诗人居住于杭州，歌咏于杭州，已经一千余年，在你泛舟于西湖之上，或攀登上孤山岛或凤凰山上，或品茗于湖滨酒馆中，你会听到杭州本地的主任嘴边常挂着“苏东坡，苏东坡”。你若指出苏东坡是四川人，他会不高兴听。他心里认为苏东坡生于杭州，除去到京都之外，何尝离开过杭州！</p>
</blockquote>
<p>在杭州，他常与僧侣为伴，亦频频为歌伎题诗。</p>
<p>书中记载了一则东坡与好友佛印的趣事。“鸟”字在中国俚语中有不雅之意，苏东坡借此字想要开佛印的玩笑。他说，“古代诗人常常将‘僧’和‘鸟’在诗中相对，例如‘鸟宿池边树，僧敲月下门’，又如‘时闻啄木鸟，疑是叩门僧’。我佩服古人以‘僧’对‘鸟’的聪慧。”</p>
<p>佛印的回应如下：</p>
<blockquote>
<p>这就是我为什么以“僧”的身份与你相对而坐的理由了。（暗指苏东坡为“鸟”）</p>
</blockquote>
<p>在北宋，文人雅士为官之时，在酒宴场合，与官妓相调戏并以诗相赠，是被接受的。东坡以其天妒之才，为各路名妓题赠了不少诗词。但纵然苏轼爱出席此等酒筵征逐，他并不沉迷声色。他的所爱，在杭州的山水之间，尤以西湖为最。他对西湖的情感，饱含在如下这首广为流传的诗中：</p>
<blockquote>
<p>水光潋滟晴方好，山色空蒙雨亦奇。</p>
<p>欲把西湖比西子，淡妆浓抹总相宜。</p>
</blockquote>
<p>当然，在杭州，与苏轼相伴的并不只有诗酒与山河。当时安石还没有被罢相，新政仍在实施。其为害之烈，一一体现在杭州的民生上。除去“荡气回肠的爱情诗，启人灵思的山水诗”，苏轼在杭州期间，也曾写下了大量“戏谑讽刺的抗暴诗”。</p>
<p><br></p>
<p>熙宁七年，苏轼转调密州（今山东诸城市，是潍坊的下辖县，与青岛毗邻）知州。因为弟弟子由在山东济州任职，于是苏东坡变在杭州任期届满之时，呈请调任到山东去。“这是苏东坡最难过、最沮丧的一段时光。”但是，他的诗才在这一时期，达到完全成熟的地步。“愤怒与苛酷的火气已无，只剩下安详平和与顺时知命的心境。”</p>
<p><br></p>
<p>熙宁九年，苏轼又被改派至徐州。在任期内，为治理黄河水患，而加强城基，增加城高。治水成功后，由于苏轼喜欢建筑，便在外围城墙上，修筑了一座楼，楼高百尺，谓之“黄楼”。后来，苏东坡在徐州任期内所作的诗歌总集，便以“黄楼”命名，正如在密州时，他曾建“超然台”，此台也成了苏东坡在密州时所写诗集的名称。</p>
<p><br></p>
<p>尚未读完，暂无定论。</p>
<p>不妨先放些摘抄。</p>
<h2 id="诗词">诗词</h2>
<blockquote>
<p>十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。</p>
<p>夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。聊得年年断肠处，明月夜，短松岗。</p>
<p>——《江城子·乙卯正月二十日夜记梦》</p>
<p>此为东坡为悼念亡妻王弗而创作的悼亡词。</p>
</blockquote>
<blockquote>
<p>东风知我欲山行，吹断檐间积雨声。</p>
<p>岭上晴云披絮帽，树头初日挂铜钲。</p>
</blockquote>
<blockquote>
<p>劝君莫惜金缕衣，劝君惜取少年时。</p>
<p>花开堪折直须折，莫待无花空折枝。</p>
</blockquote>
<h2 id="林语堂原文">林语堂原文</h2>
<blockquote>
<p>使文学作品有别于一般作品，就在于在精神上取悦于人的声韵、感情、风格而已。</p>
</blockquote>
<blockquote>
<p>对国运为害之烈，再没有如庸妄之辈大权在握、独断独行时之甚得了。</p>
</blockquote>
<blockquote>
<p>所谓华美靡丽的风格，可以说就是堆砌艰深难解之辞藻与晦涩罕见的典故，以求文章之美。在此等文章里，很难找到一两行质朴自然的句子。最忌讳指物直称其名，最怕句子质朴无华。苏东坡称这种炫耀浮华的文章里构句用字各自为政，置全篇效果于不顾，如演戏之开场日，项臂各挂华丽珠宝的老妪一样。</p>
</blockquote>
<blockquote>
<p><em>读苏东坡来信，不知为何，我竟喜极汗下。老夫当退让此人，使之出人头地。</em></p>
<p><em>——欧阳修</em></p>
</blockquote>
<blockquote>
<p>苏东坡这时轻松愉快，壮志凌云，才气纵横而不可抑制，一时骅骝长嘶，奋蹄蹴地，有随风飞驰、征服四野八荒之势。</p>
</blockquote>
<blockquote>
<p>在历史上，多少政治的罪恶都是假借“人民”的名义而犯下的，现代的读者自然不难明白。</p>
</blockquote>
]]></content>
      <categories>
        <category>书架</category>
      </categories>
      <tags>
        <tag>苏东坡传</tag>
      </tags>
  </entry>
  <entry>
    <title>关于archer主题的一些进阶配置</title>
    <url>/%E5%85%B3%E4%BA%8Earcher%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="开启gitalk">开启gitalk</h1>
<p>只需要在github上开启一个OAuth application就可以。</p>
<p>具体做法为：</p>
<ol type="1">
<li>在github中定位到<code>Settings &gt; Developer settings &gt; OAuth Apps</code>，新建一个OAuth应用。</li>
<li>新建一个专门用于存放comments的仓库，一般设为公有。</li>
<li>将配置信息添加到archer的配置文件中。</li>
</ol>
<p><br></p>
<h1 id="gitalk评论内容框样式修改">gitalk评论内容框样式修改</h1>
<p>默认的gitalk评论框是方角的，但是编辑框又是圆角的，<del>让强迫症很不爽</del>。另外，在黑暗模式下，悬浮评论框发的白光真的有点抱看。</p>
<p><code>themes\archer\layout\_partial\comment\gitalk.ejs</code>中，引入了一个css文件<code>https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css</code>。</p>
<p>我们把这个css下载到本地并放在<code>source\</code>下，作如下修改。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.gt-container</span> <span class="selector-class">.gt-comment-content</span> &#123;</span><br><span class="line">  -webkit-box-<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">      -ms-<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">          <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">1.25em</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.75em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f9f9f9</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: all ease <span class="number">0.25s</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all ease <span class="number">0.25s</span>;</span><br><span class="line">  <span class="comment">/* 添加下面这行代码 */</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注释掉如下代码 */</span></span><br><span class="line"><span class="comment">/* .gt-container .gt-comment-content:hover &#123;</span></span><br><span class="line"><span class="comment">  -webkit-box-shadow: 0 0.625em 3.75em 0 #f4f4f4;</span></span><br><span class="line"><span class="comment">          box-shadow: 0 0.625em 3.75em 0 #f4f4f4;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后在<code>themes\archer\layout\_partial\comment\gitalk.ejs</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css&quot;&gt; --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/gitalk.css&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>这样，gitalk组件使用的就是我们自己的样式表了。</p>
<p><br></p>
<h1
id="gitalkarcher样式适配其实是个bug">gitalk+archer样式适配（其实是个bug）</h1>
<p>默认情况下，在黑暗模式下，gitalk评论框背景和前景都是白色的，导致文字完全看不清。这不是gitalk的样式问题，是archer源文件中<code>themes\archer\source\css\dark.css</code>的关于gitalk的样式错误了。</p>
<p>修改方式为：在<code>themes\archer\source\css\dark.css</code>中添加：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* MARK! This is modified by LULU! */</span></span><br><span class="line"><span class="selector-id">#gitalk-container</span> <span class="selector-tag">textarea</span>,</span><br><span class="line"><span class="selector-id">#gitalk-container</span> <span class="selector-class">.gt-header-preview</span> *,</span><br><span class="line"><span class="selector-id">#gitalk-container</span> <span class="selector-class">.gt-comment-content</span> * &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已提出pull request。</p>
<hr />
<p><strong>以上方法已弃用，因为是错误的！</strong></p>
<p>archer作者使用了scss，<code>source</code>中的所有文件是根据<code>src</code>中的源码通过<code>npm run build</code>自动构建生成的。每次构建，source中的静态文件都会被覆盖。</p>
<p><strong>正确方法是</strong>：更改<code>themes\archer\src\scss\_dark\_partial\_comment\_gitalk-dark.scss</code>。然后运行<code>npm run build</code>。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#gitalk-container</span> &#123;</span><br><span class="line">  * &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$post-content-color-dark</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加下面五个选择器，将编辑框，预览框和展示框，以及元信息区的action与version文本的文字都设置成深色即可</span></span><br><span class="line">  <span class="selector-tag">textarea</span>,</span><br><span class="line">  <span class="selector-class">.gt-header-preview</span> *,</span><br><span class="line">  <span class="selector-class">.gt-comment-content</span> *,</span><br><span class="line">  <span class="selector-class">.gt-action</span> *,</span><br><span class="line">  <span class="selector-class">.gt-version</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$gt-color-main</span> <span class="meta">!important</span>;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="variable">$gt-color-main-lighter</span> <span class="meta">!important</span>;</span><br><span class="line">      <span class="attribute">border-color</span>: <span class="variable">$gt-color-main-lighter</span> <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h1 id="开启版权信息">开启版权信息</h1>
<p>原本的样式是这样的：</p>
<p><img src="https://s2.loli.net/2022/09/18/vqZOTYbe4Hmzioy.png" /></p>
<p>我觉得下方的虚线有些难看，另外日期格式不太符合中国人习惯，所以对源码进行了修改。</p>
<p>首先修改下边框虚线。</p>
<p>定位到<code>themes\archer\source\css\style.css</code>，将<code>license-warpper</code>选择器中的<code>border-bottom</code>注释掉即可。</p>
<p>修改后的效果为：</p>
<p><img src="https://s2.loli.net/2022/09/18/QIP79f4gr81iejU.png" /></p>
<p>然后，需要调整日期输出格式。</p>
<p><code>themes\archer\layout\post.ejs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;% if(theme.copyright.enable === true &amp;&amp; page.copyright !== false) &#123; %&gt;</span><br><span class="line">    &lt;div class=&quot;license-wrapper&quot;&gt;</span><br><span class="line">        &lt;p&gt;&lt;%- __(&#x27;author&#x27;) %&gt;：&lt;a href=&quot;&lt;%- config.url %&gt;&quot;&gt;&lt;%- config.author %&gt;&lt;/a&gt;</span><br><span class="line">        &lt;p&gt;&lt;%- __(&#x27;post_link&#x27;) %&gt;：&lt;a href=&quot;&lt;%- page.permalink %&gt;&quot;&gt;&lt;%- page.permalink %&gt;&lt;/a&gt;</span><br><span class="line">        &lt;!-- MARK! This is modified by LULU! --&gt;</span><br><span class="line">        &lt;p&gt;&lt;%- __(&#x27;publish_date&#x27;) %&gt;：&lt;a href=&quot;&lt;%- page.permalink %&gt;&quot;&gt;&lt;%- (page.date).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) %&gt;&lt;/a&gt;</span><br><span class="line">        &lt;p&gt;&lt;%- __(&#x27;update_date&#x27;) %&gt;：&lt;a href=&quot;&lt;%- page.permalink %&gt;&quot;&gt;&lt;%- (page.updated).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) %&gt;&lt;/a&gt;</span><br><span class="line">        &lt;p&gt;&lt;%- __(&#x27;license&#x27;) %&gt;：&lt;%- theme.copyright.license %&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>
<p>个人感觉很满意~</p>
<p><strong>PS：在更改的源码的上方注释了一行<code>MARK! This is modified by LULU!</code>。</strong></p>
<p><br></p>
<h1
id="algolia的cicd配置与新博客发表方法">algolia的CI/CD配置，与新博客发表方法</h1>
<p>由于使用了第三方搜索引擎algolia，新添加的博客在默认情况下并不会自动被algolia收录到索引里面，这就需要我们配置每次push之后的自动更新工作流。</p>
<p>在项目仓库<strong>LuLu010722.github.io</strong>中，创建新的分支<code>source</code>，将本地文件push到该分支上，主分支<code>main</code>用于保存由github-page-deploy工具自动生成的文件。</p>
<p>在本地<code>.github</code>文件夹中，添加<code>workflows/main.yml</code>，编写<a
href="https://github.com/LuLu010722/LuLu010722.github.io/blob/source/.github/workflows/main.yml">workflow
file</a>。</p>
<p>需注意，由于我们启用了<span
class="math inline">\(\LaTeX\)</span>支持，则需要在服务器上安装本地的pandoc包，这个要放到workflow
file中去。</p>
<p><strong>然后每次在本地添加了新的博客之后，不再用之前的更新方式，</strong></p>
<p>而是将改动先在<code>source</code>分支上提交，然后push到远程<code>origin/source</code>分支。</p>
<p>该行为会依次启动algolia的更新工作流和gh-pages的构建工作流。</p>
<p>两个工作流都成功之后，宣告成功。</p>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>泉さんとの相談</title>
    <url>/%E6%B3%89%E3%81%95%E3%82%93%E3%81%A8%E3%81%AE%E7%9B%B8%E8%AB%87/</url>
    <content><![CDATA[<blockquote>
<p>とっても突然ですけど、申し訳ございません。私は、泉さんに言いたいことがあるから。</p>
<p>一年半くらい前に、王路児さんは私の彼女になりましたのは、もうお覚えでしょうか。私たちは素晴らしい時間を過ごしました。少なくとも私はそう思いました。しかし、三ヶ月くらい前に、私たちは別かれてしまいました。</p>
<p>私は今までも、毎日とっても苦しんで過ごしていたんでした。毎日、いったいどうやってその人の心を取り戻せるのかとずうっと考えていました。</p>
<p>彼女は今、東京大学で交換留学しています。それは、泉さんはもう知っていましたかもしれません。彼女は、日本の研究環境はとても自由で楽しそうだと思いましたから、卒業した東大の修士に申し込むつもりです。</p>
<p>彼女は、うちの大学でいい成績を持ち、日本語は中学からずっと勉強していたからすごく上手、東大で交換留学した経験もありますから、東大の修士に合格する可能性が高いんです。</p>
<p>だから、復縁する思いを持っている私は、一緒に東大の修士になれるように、頑張りたいんです。だからこそ、私は今、真面目に日本語を独学したり、TOEFLに合格するために英語も勉強したりしています。</p>
<p>でもさあ、それはばかばかしいといわれてしまうかもしれませんね。泉さんはどう思うんですか？ずっと前から泉さんを尊敬しているので、今日はわざと泉さんのご意見を伺います。</p>
<p>（今、ただN３のレベルので、以上の書いた言語は間違いがたくさんありますかもしれないのは、すみません。）</p>
</blockquote>
<p><br></p>
<blockquote>
<p>お久ぶりです。返事が遅れてごめんなさい。</p>
<p>まず、言いたいことは大体わかりました。日本語本当に上手になったね。</p>
<p>お二人が別れたと聞いてとても残念です。</p>
<p>卢くんがまだ王さんとお付き合いするために勉強を頑張っているのも立派だと思います。</p>
<p>でも、なぜ別かれてしまったのかは冷静に考えたほうがいいと思います。</p>
<p>今東京と上海は遠く、簡単には会いに行けないと思います。そのことだけが原因で別れたのなら、卢くんも東京に留学すれば、またお付き合いできると思います。</p>
<p>一方で、王さんは東京で勉強に集中したくて別れた可能性はありませんか？それのも別かれる前に喧嘩とかしてないですか？そのような場合、東京に来れてもまだお付き合いできるとは限りませんよね。</p>
<p>私は卢さんの努力をばかばかしいとは絶対に言いません。でも、一度卢くんご自身で別れるまでの経緯を振り返ってみて、今の努力が報われるか考えてみてはどうでしょうか？</p>
</blockquote>
<p><br></p>
<blockquote>
<p>ご返事してくださってすごく嬉しかったです。ありがとうございます！</p>
<p>泉さんのおっしゃる通りです。問題の核心は、私たちの別れる原因です。</p>
<p>ちょっと複雑ですが、なるべく日本語でご説明いたします。</p>
<p>彼女は、私は生まれた今まで最も好きになった女の子でした。それに加えて、私はもう交通大学のようないい大学（少なくとも中国で）が合格しましたので、自分の人生はこれからきっと最高でうまくいけますと思っていたから、勉強を頑張らないようになってしまいました。頑張らなくても、未来にはきっといい仕事といい妻ができると思っていたから。まあ、もちろん今更思えば、それはとっても幼稚な考えだけでした。</p>
<p>それで、彼女はますます、私の向上心が足りないと思うことになります。嫌気もだんだん増えました。</p>
<p>それに対して、私は、彼女は私と一緒にいるのに、十分な時間を割いていないと思いますから、先に「別れよう」といいました。でも、それは本気ではなかった。私をもっと大切にしてもらうためだけの腹立たしい言葉でした。しかし、彼女は「じゃあ、そうしよう。君はこの一年に私のそばにいてくれてありがとう。もっと適した彼女が見つけるように。」といいました。</p>
<p>別れた後、私はどうしても彼女を忘れられなかった。</p>
<p>以前の自分をよく反省します。確かにその「この人生はもう最高だ」という思いはとっても幼稚なだと思います。</p>
<p>だからこそ、いま努力するのが始まりたいんです。でも、彼女はもう二度と私のことに好きにならないかもしれないとか、新しい男の子のことに好きになるかもしれないとかと思うと、私はすぐにすごく落ち込んでしまいます。努力する気も一瞬でなくなってしまいます。</p>
<p>こんなにたくさん愚痴を言って、ほんとにごめんなさい。でも、いま私はとてもつらく生きています。どうすればいいのかもよくわかりません。泉さんから、優しい言葉を言っていただきたいんです。ご迷惑をかけて申し訳ございません。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>また返事遅れてすみません！木曜金曜は仕事が長引いて返事できませんでした。</p>
<p>なるほど、お互いの勉強への姿勢の違いがあったのなら、別れてもしょうがない気がします。</p>
<p>立派な大学を出れば立派な人生を送れると思ってしまう気持ちはわかります。別に怠惰だなんて思わないよ。</p>
<p>一方で、夢中になれる勉強があると時間がいくらあっても足りないんですよね。王さんの気持ちもわかります。</p>
<p>結局は二人の時間の使い方の違いでしかなくて、別れたのも仕方なかったんじゃないかと思います。</p>
<p>それでも卢くんが復縁したいなら、勉強を頑張るよりもお互いの価値観を理解することが大事かもしれません。お互いが勉強や仕事に夢中になったら、結局すれ違いで別れてしまうことになるかもしれませんよ？</p>
<p>だから、不安に思いながら勉強するくらいなら、王さんに連絡してみるのはどうでしょうか？お互い価値観の違いを知ってもお付き合いを続けられるか、話してみてはどうでしょうか？</p>
<p>もちろん王さんはもう彼氏がいるかもしれませんが、それで知らずに思い悩むよりはマシだと思いますよ。「案ずるより産むがやすし」です。</p>
</blockquote>
<p><br></p>
<blockquote>
<p>返事がちょっと遅れるので謝る必要が全然ありません！泉さんは優しい言葉を言ってくれて、それだけで元気づけられました。</p>
<p>お忙しいところで、こんなに面倒な質問をするのが、恥ずかしくてすみません。</p>
<p>実は、彼女に連絡することができませんからこそ、二人の周りの人を相談するんでした。</p>
<p>でも、彼女は日本へ出発する前に、私たちは約束しました。彼女はどうしても私と恋愛を続けたくないから、私は「じゃあ、私は君を放して、君は日本へ行こう。でもせめて、半年後に君は帰国した学校帰った時には、二人はもう一回会おうはどうでしょうか？」って言った。彼女は同意しました。</p>
<p>この間に、彼女は新しい彼氏ができないことを祈っていました(笑)。そして、私もこの半年くらいの時間に、もっと優れた自分をその人に見せるように、自分を変えてやる。結局はどうになるのは予想できないんですが、そうしなきゃならないんだよね。</p>
<p>それより、もし未来には私は本当に東京へ行ったら、ぜひ泉さんのお宅を訪ねて伺います！楽しみですね。</p>
<p>ちなみに、私は最近lineのアカウントができた。もしよければ、交換してもいいですか？</p>
</blockquote>
]]></content>
      <categories>
        <category>日本語</category>
      </categories>
      <tags>
        <tag>雑談</tag>
      </tags>
  </entry>
  <entry>
    <title>可可的琴</title>
    <url>/%E5%8F%AF%E5%8F%AF%E7%9A%84%E7%90%B4/</url>
    <content><![CDATA[<h1 id="寒鸦戏水">寒鸦戏水</h1>
<audio id="audio" controls="" preload="none">
<source src="/assets/寒鸦戏水.mp3">
</audio>
<blockquote>
<p>等我一会儿~</p>
</blockquote>
<p><strong>演奏者</strong>：可可同学，可爱的可</p>
<p><strong>曲目</strong>：寒鸦戏水</p>
]]></content>
      <categories>
        <category>展厅</category>
      </categories>
      <tags>
        <tag>可可</tag>
        <tag>音乐</tag>
        <tag>古琴</tag>
      </tags>
  </entry>
  <entry>
    <title>我的画</title>
    <url>/%E6%88%91%E7%9A%84%E7%94%BB/</url>
    <content><![CDATA[<h1 id="pro-create">Pro Create</h1>
<p><img src="/images/procreate.jpg" /></p>
<p><strong>日期</strong>：2022-9-19</p>
<p><br></p>
<h1 id="炭治郎">炭治郎</h1>
<p><img src="/images/tanjirou.jpg" /></p>
<p><strong>日期</strong>：2022-9-24</p>
<p><br></p>
<h1 id="香奈乎">香奈乎</h1>
<p><img src="/images/kanao.jpg" /></p>
<p><strong>日期</strong>：2022-9-25</p>
]]></content>
      <categories>
        <category>展厅</category>
      </categories>
      <tags>
        <tag>绘画</tag>
      </tags>
  </entry>
  <entry>
    <title>Daily Report</title>
    <url>/daily-report/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="section">2022-09</h1>
<h2 id="section-1">16</h2>
<ol type="1">
<li>搭建了hexo个人博客。</li>
<li>配置了两种主题：keep和archer。</li>
<li>添加了以pandoc为引擎的<span
class="math inline">\(\LaTeX\)</span>扩展。</li>
<li>两篇博客。</li>
<li>看了一点机器学习。</li>
<li>keep25分钟腿（腿已废）。</li>
</ol>
<p><strong>是收获满满的一天，希望自己能够坚持下来！加油！</strong></p>
<hr />
<h2 id="section-2">17</h2>
<ol type="1">
<li>粗略看完了西瓜书第二章，发现概统中的一些概念已经忘了（比如假设检验）。</li>
<li>配置了博客评论gitalk。</li>
<li>修复了about页没有intro-image的bug（是因为<code>about</code>文件夹中的<code>index.md</code>没有加layout的front
matter）。</li>
<li>添加了404页（May the force be with you :)）。</li>
<li>更新了about页~。</li>
</ol>
<hr />
<h2 id="section-3">18</h2>
<ol type="1">
<li>对archer版权信息框和gitalk默认样式进行了微调，主要包括：
<ol type="1">
<li>取消了版权内容的条状下边框，对应<code>themes\archer\src\scss\_partial\_post-page.scss</code>。</li>
<li>对版权日期显示格式进行了规范，对应<code>themes\archer\layout\post.ejs</code></li>
<li>添加评论显示框的圆角，对应<code>source\gitalk.css</code>。</li>
<li>取消了评论显示区的hover特效，对应<code>source\gitalk.css</code>。</li>
<li>修改了在暗黑模式下，gitalk元信息区action按钮、version文本、编辑区、预览区、评论展示区的前景色，对应<code>themes\archer\src\scss\_dark\_partial\_comment\_gitalk-dark.scss</code>。</li>
</ol></li>
<li>配置了algolia搜索引擎，并配置了其自动更新索引的github工作流，并修复了pandoc依赖缺失的问题。参考<a
href="https://zhuanlan.zhihu.com/p/508457566">这一篇知乎</a>。</li>
<li>提交了我的第一个github pull request，尝试修复archer主题的一个<a
href="https://github.com/fi3ework/hexo-theme-archer/pull/344">小bug</a>，即上面提到的1.5。已成功被merge，解锁了github成就！😍</li>
<li>对博客仓库结构进行了调整。</li>
<li>改用了另外的<a href="https://sm.ms/">图床</a>。</li>
<li>在博客相邻的标题间，添加了&lt;br&gt;。</li>
</ol>
<p>学习了很多github CI/CD的知识，包括github actions的workflow
file怎么写，这个是真的恶心。😢</p>
<hr />
<h2 id="section-4">19</h2>
<ol type="1">
<li>应用体系架构作业一第一部分，虽然还要再修改一下。</li>
<li>开始Pro Create！<a
href="https://lulu010722.cn/%E6%88%91%E7%9A%84%E7%94%BB/">处女作</a>。</li>
</ol>
<hr />
<h2 id="section-5">20</h2>
<ol type="1">
<li>博客首页摘要格式化功能开启。</li>
<li>博客图片圆角。</li>
<li>asa作业一第一题完成。</li>
<li>keep20分钟核心。</li>
</ol>
<hr />
<h2 id="section-6">21</h2>
<ol type="1">
<li>阅读《月亮与六便士》，至75%。</li>
<li>修复了index页摘要标题行距bug。</li>
</ol>
<p>对于过日子来说，今天是碌碌无为的；可是，我它用来放飞了灵魂。</p>
<hr />
<h2 id="section-7">22</h2>
<ol type="1">
<li>读完《月亮与六便士》，并撰写了读后感。</li>
<li>那封信。</li>
<li>开始阅读《苏东坡传》。</li>
<li>配置了cse lab1环境。</li>
</ol>
<hr />
<h2 id="section-8">23</h2>
<ol type="1">
<li>修复了sidebar时间显示NaN/aN/aN的问题，原因是hexo配置文件中jsonContent字段的date设置为了false。</li>
<li>自定义摘要长度，方法为在hexo配置文件中添加excerpt字段，并调节depth。</li>
<li>修改了主页每页博客数量，目前为5。</li>
<li>《苏东坡传》，20%。</li>
<li>keep27分钟臀腿+核心。</li>
</ol>
<hr />
<h2 id="section-9">24</h2>
<ol type="1">
<li><a
href="https://lulu010722.cn/%E6%88%91%E7%9A%84%E7%94%BB/">炭治郎</a>临摹（其实是像素级抄袭~）。</li>
<li>蝴蝶忍正在上色。</li>
<li>《苏东坡传》，30%。</li>
</ol>
<p>今天是纯纯不务正业的一天啊哈哈哈~~。</p>
<hr />
<h2 id="section-10">25</h2>
<ol type="1">
<li><a
href="https://lulu010722.cn/%E6%88%91%E7%9A%84%E7%94%BB/">香奈乎</a>完工。</li>
<li>应用体系架构（后面就简称app吧）作业一完成，将遇到的坑总结在了<a
href="https://lulu010722.cn/jpa%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%A4%96%E9%94%AE%E6%AD%BB%E9%94%81/">新博客</a>。</li>
<li>启用了博客的mermaid图表功能。</li>
</ol>
<hr />
<h2 id="section-11">26</h2>
<ol type="1">
<li>控线练习3页。</li>
</ol>
<hr />
<h2 id="section-12">27</h2>
<ol type="1">
<li>心理咨询。</li>
<li>控线练习1页。</li>
<li>跑步3.08km，用时16'17''。</li>
</ol>
<hr />
<h2 id="section-13">28</h2>
<ol type="1">
<li>跑步3.06km，用时14'55''。</li>
</ol>
<hr />
<h2 id="section-14">29</h2>
<ol type="1">
<li>编译原理lab2完成。</li>
<li>控线练习1页。</li>
<li>《苏东坡传》40%。</li>
<li>博客公私仓库分离。</li>
<li>跑步3.02km，用时14'21''。</li>
</ol>
<hr />
<h2 id="section-15">30</h2>
<ol type="1">
<li>起草第二封信。</li>
<li>《苏传》50%。</li>
<li>跑步3.00km，用时14'46''。</li>
</ol>
<hr />
<p><br></p>
<h1 id="section-16">2022-10</h1>
<h2 id="section-17">1</h2>
<ol type="1">
<li>和琛琛打网球1h。</li>
<li>跑步3.03km，用时13'43''。</li>
</ol>
<p>与国同庆，今天给自己放个小假~。</p>
<hr />
<h2 id="section-18">2</h2>
<ol type="1">
<li>cse lab1 part1A完成。</li>
<li>跑步3.03km，用时14'16''。</li>
</ol>
<hr />
<h2 id="section-19">3</h2>
<ol type="1">
<li>cse lab1 part1B完成。</li>
</ol>
<p>好久不去ktv了，唱了很多日语歌，至少彼时彼刻，很开心。</p>
<hr />
<h2 id="section-20">4</h2>
<ol type="1">
<li>cse lab1 part1CD完成。</li>
</ol>
<hr />
<h2 id="section-21">5</h2>
<ol type="1">
<li>白色相簿2ic50%。</li>
</ol>
<hr />
<h2 id="section-22">6</h2>
<ol type="1">
<li>白色相簿2ic完成。</li>
</ol>
<p>好的作品，跨越爱好，跨越年代。还是小看了二次元的精神丰富度。</p>
<hr />
<h2 id="section-23">7</h2>
<ol type="1">
<li>cse-lab1 part2ABC完成<del>（虽然放弃了part2D的symlink）</del>。</li>
<li>《苏传》60%。</li>
</ol>
<hr />
<h2 id="section-24">8</h2>
<ol type="1">
<li>app作业二完成。</li>
<li>推了一会wa2的cc。</li>
</ol>
<hr />
<h2 id="section-25">9</h2>
<ol type="1">
<li>compiler复习，lab3环境准备。</li>
<li>《苏传》70%。</li>
</ol>
<hr />
<h2 id="section-26">10</h2>
<ol type="1">
<li>白2大三圣诞节。</li>
<li>和巢老师谈话。</li>
</ol>
<hr />
<h2 id="section-27">11</h2>
<ol type="1">
<li>白2cc雪菜线完结。</li>
</ol>
<hr />
<h2 id="section-28">12</h2>
<ol type="1">
<li>ML作业1。</li>
</ol>
<hr />
<h2 id="section-29">13</h2>
<ol type="1">
<li>音频上传。</li>
</ol>
<hr />
<h2 id="section-30">14</h2>
<ol type="1">
<li>算法作业1完成。</li>
<li>2.03km，10'28''。</li>
</ol>
<hr />
<h2 id="section-31">15</h2>
<ol type="1">
<li>复习了ICS第七章。</li>
<li>一个github issue，问题是post中表格头显示异常（已被解决）。</li>
<li>3.17km，16'07''。</li>
</ol>
<hr />
<h2 id="section-32">16</h2>
<ol type="1">
<li>复习了ICS第八章。</li>
<li>两个PR，均已被merge。</li>
<li>提出关于archer TOC的issue，已被响应<del>（甩锅）</del>。</li>
<li>博客和archer仓库重构。</li>
<li>2.01km，12'03''。</li>
</ol>
<p>尝试了在blog主仓库，添加archer作为子模块。期望达到的目标为：在日常更新主仓库的博客等内容时，可以同时对archer进行贡献或者个性化修改。archer的目录需要暴露给blog，因为blog需要用到archer中的文件进行页面渲染。有待探索。</p>
<hr />
<h2 id="section-33">17</h2>
<ol type="1">
<li><p>放弃github CI/CD，改用本地构建然后直接部署到public
repo。原因有两个：</p>
<ol type="1">
<li>如果通过push到私有仓库，在远端构建并部署，则需要下载pandoc等依赖，比较复杂。</li>
<li>actions/checkout@v3会将source的内容克隆到服务器上，但是克隆会覆盖文件的修改时间，导致博客页面上的所有博客的修改时间均为克隆时间，而git又没有提供解决办法。</li>
</ol>
<p>顺便写了个脚本<code>go.bat</code>，一步到位~。</p></li>
<li><p>顺便解决了时区的问题。因为是本地构建，所以时间正常显示。</p></li>
<li><p>学习了git submodule的使用方法，解决了昨天的遗留问题。总结在了<a
href="https://lulu010722.cn/git%E2%80%94%E2%80%94%E4%BA%BA%E7%B1%BB%E5%A5%BD%E6%9C%8B%E5%8F%8B/">这篇博客中</a>。</p></li>
</ol>
<hr />
<h2 id="section-34">18</h2>
<ol type="1">
<li>复习了ICS第九章。</li>
<li>复习了compiler关于parser的部分，编写了部分lab3代码。</li>
<li>3.09km，15'45''。</li>
<li>写了一点点mine主题。</li>
</ol>
<hr />
<h2 id="section-35">19</h2>
<ol type="1">
<li>更新了about页，因为突然想起来，VG100的项目也可以列进去~🤗。</li>
<li>改了改日记里面对博客的引用，因为前几天改了permalink的格式。</li>
<li>连追八集边缘行者😍。</li>
<li>3.04km，12'53''。</li>
<li>compiler lab3第一版<del>（虽然一直syntax error）</del>。</li>
</ol>
<hr />
<h2 id="section-36">20</h2>
<ol type="1">
<li>3.15km，15'19''。</li>
</ol>
<hr />
<h2 id="section-37">21</h2>
<ol type="1">
<li>看医生。</li>
<li>研究了ipads面试论文，基本搞懂了机器学习辅助缓存的基本原理。</li>
</ol>
<hr />
<h2 id="section-38">22</h2>
<ol type="1">
<li>ipads面试，自我感觉一般quq。</li>
<li>完成了compiler的lab3。</li>
<li>修补了cse lab1
2d部分未完成的任务，同时将代码迁移到wsl上，避免后续挂载问题。</li>
<li>3.53km，18'55''。</li>
</ol>
<hr />
<h2 id="section-39">23</h2>
<ol type="1">
<li>散步<span class="math inline">\(n\)</span>圈（<span
class="math inline">\(n\ge8\)</span>）。由于一直在聊天所以实在不记得了hhh。</li>
</ol>
<p>小法绝活练成（bushi）。另外，大概可能要开始写信了呀。</p>
<hr />
<h2 id="section-40">24</h2>
<ol type="1">
<li>第二封信。</li>
</ol>
<hr />
<h2 id="section-41">25</h2>
<ol type="1">
<li>学长碎碎念。</li>
</ol>
<hr />
<h2 id="section-42">26</h2>
<ol type="1">
<li>yh碎碎念，甚至帮做ppt了hhh。</li>
</ol>
<hr />
<h2 id="section-43">27</h2>
<ol type="1">
<li>af碎碎念。</li>
</ol>
<p>这几天只剩下碎碎念了。。。</p>
<hr />
<h2 id="section-44">28</h2>
<ol type="1">
<li>aea作业4完成。</li>
<li>理清了一些关于摘要，签名，证书的原理。</li>
</ol>
<hr />
<h2 id="section-45">29</h2>
<ol type="1">
<li>完成cse lab2A part1 part2。</li>
<li>直系学长东工大留学经验分享。听完感觉又有点信心了hh。</li>
</ol>
<hr />
<h2 id="section-46">30</h2>
<ol type="1">
<li>完成cse lab2A part3。</li>
<li>完成算法作业2。</li>
</ol>
<hr />
<h2 id="section-47">31</h2>
<ol type="1">
<li>复习了compiler type checking，开工lab4。</li>
<li>综合日语第二次，16课朗读+词汇背诵。</li>
</ol>
<hr />
<p><br></p>
<h1 id="section-48">2022-11</h1>
<h2 id="section-49">1</h2>
<ol type="1">
<li>完成了大部分compiler lab4。</li>
</ol>
<h2 id="section-50">2</h2>
<ol type="1">
<li>完成了lab4。</li>
<li>复习compiler，因为明天要考试了quq。</li>
</ol>
<hr />
<h2 id="section-51">3</h2>
<ol type="1">
<li>compiler考试，发挥正常。</li>
<li>看医生。</li>
</ol>
<hr />
<h2 id="section-52">4</h2>
<ol type="1">
<li>《明朝那些事儿（一）——洪武大帝》10%。</li>
<li>JLPT
N1-N5的例题全都挑战了一遍，发现自己目前大概在N4-N3之间的水平。不过，利用中国人的汉语和英语加成，N2的读解文章也能大概看懂，需要更多练习听解。</li>
<li>试做了2011.12
N3真题，刨除尺度计分的因素，综合得分大概135分左右，超过了95分的及格线。已复盘。</li>
</ol>
<hr />
<h2 id="section-53">5</h2>
<ol type="1">
<li>2011.07 N3，刨除尺度计分，146。已复盘。</li>
<li>JLPTというアプリで単語を70個覚えました。</li>
</ol>
<hr />
<h2 id="section-54">6</h2>
<ol type="1">
<li>新しい単語を７０（N2）＋１２０（N5）個覚えました。前に覚えた単語を７０個を復習した。</li>
<li>2012.07 N3，言语部分-11分，读解-8分。</li>
<li>简单了解了fair division和stable
match的问题，准备周三与陶老师见面。</li>
</ol>
<hr />
<h2 id="section-55">7</h2>
<ol type="1">
<li>新しい単語７０個。７０個を復習した。</li>
</ol>
<hr />
<h2 id="section-56">8</h2>
<ol type="1">
<li>新しい単語７０個。７０個を復習した。</li>
<li>陶老师的论文浅读。</li>
</ol>
<hr />
<h2 id="section-57">9</h2>
<ol type="1">
<li>和陶老师进行了交流，基本介绍了研究方向和问题。</li>
<li>新しい単語７０個。７０個を復習した。</li>
</ol>
<hr />
<h2 id="section-58">10</h2>
<ol type="1">
<li>泉さんとご相談をしました。</li>
<li>新しい単語３５個。７０個を復習した。</li>
<li>cse lab2B完成。</li>
<li>ML hw2完成。</li>
<li>飛くんとジョギングをした。</li>
</ol>
<hr />
<h2 id="section-59">11</h2>
<ol type="1">
<li>ML lab1完成。</li>
<li>新しい単語３５個。３５個を復習した。</li>
<li>2012.07 N3 听解-17分，总分144。复盘了言语，读解和部分听解。</li>
<li>飛くんとジョギングをした。</li>
</ol>
<hr />
<h2 id="section-60">12</h2>
<ol type="1">
<li>完成了algorithm
assignment3。尝试学习tikz画图论用图，但是失败了。。</li>
<li>JLPTでN3の模擬試験は参加しました。得点はまだ出ていない。でも、聴解問題はちょっと難しかったな。</li>
<li>新しい単語３５個。</li>
</ol>
<hr />
<h2 id="section-61">13</h2>
<ol type="1">
<li>Talked with Aysu.</li>
<li>単語３５個。</li>
<li>复习了cse部分知识。明天还要继续，否则后天寄了哇。。</li>
</ol>
<p>今天外卖能送到楼下了，本学期第一次在楼下取到外卖，有点怀念了😭。</p>
<hr />
<h2 id="section-62">14</h2>
<ol type="1">
<li>复习了cse，包括乐观并发控制，事务原子控制，谷歌文件系统，inode-based文件系统等等。</li>
<li>単語３５個。</li>
</ol>
<p>今天连翘了三节课复习，结果晚上陈老师来问问题还是不会，哎，希望明天加油吧。。</p>
<hr />
<h2 id="section-63">15</h2>
<ol type="1">
<li>cse期中考，感觉发挥非常不好。</li>
<li>単語７０個。</li>
<li>2012.12 N3 言语-10，语法-4，听力-2，总分164！头一次上160hh。</li>
<li>复习了一点compiler activation record内容。</li>
</ol>
<hr />
<h2 id="section-64">16</h2>
<ol type="1">
<li>単語３５個。</li>
</ol>
<p><br></p>
<h1 id="todo">TODO</h1>
<ol type="1">
<li>生成文件中大量空白。与<code>themes\archer\layout\_partial\sidebar\sidebar-archives.ejs</code>有关，大概需要学习ejs语法。</li>
<li>自动检测&lt;br&gt;。</li>
<li>TOC修改。</li>
<li>archer本地搜索。根据<code>hexo-generator-searchdb</code>生成的文件编写js。</li>
<li>一个idea：可以添加私有文章系统，通过手动输入秘钥来解锁。</li>
</ol>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>每日活动记录</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习概论</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="nfl定理">NFL定理</h1>
<p><strong>No Free Lunch Theorem</strong>：天下没有免费的午餐</p>
<p>我们计算一个学习算法<span
class="math inline">\(\mathcal{L}_a\)</span>的“训练集外误差”，有 <span
class="math display">\[
\begin{aligned}
  E_{ote}(\mathcal{L}_a|X,f)=\sum_{h}\sum_{x\in\mathcal{X}-X}P(x)\mathbb{I}(h(x)\ne
f(x))P(h|X,\mathcal{L}_a)
\end{aligned}
\]</span></p>
<p>如果对于所有真实目标函数<span
class="math inline">\(f\)</span>求和，则有 <span class="math display">\[
\begin{aligned}
  \sum_f E_{ote}(\mathcal{L}_a|X,f)&amp;=\sum_f\sum_h\sum_{x\in
\mathcal{X}-X}P(x)\mathbb{I}(h(x)\ne f(x))P(h|X,\mathcal{L}_a)\\
  &amp;=\sum_{x\in\mathcal{X}-X}P(x)\sum_hP(h|X,\mathcal{L}_a)\sum_f\mathbb{I}(h(x)\ne
f(x))\\
  &amp;=\sum_{x\in
\mathcal{X}-X}P(x)\sum_hP(h|X,\mathcal{L}_a)\frac{1}{2}2^{|\mathcal{X}|}\\
  &amp;=\frac{1}{2}2^{|\mathcal{X}|}\sum_{x\in
\mathcal{X}-X}P(x)\sum_hP(h|X,\mathcal{L}_a)\\
  &amp;=\frac{1}{2}2^{|\mathcal{X}|}\sum_{x\in \mathcal{X}-X}P(x)\\
\end{aligned}
\]</span>
我们可以看到，总误差与学习算法无关，也就是说，对于任意两个学习算法<span
class="math inline">\(\mathcal{L}_a\)</span>，<span
class="math inline">\(\mathcal{L}_b\)</span>，无论看上去<span
class="math inline">\(\mathcal{L}_a\)</span>多复杂，多聪明，在期望的意义下，他们的性能是相同的。<del>（也就是说，随便瞎猜和复杂推导一样，不学了
(*｀皿´*)ﾉ ）</del></p>
<p><br></p>
<h1 id="尝试证明auc计算公式">尝试证明AUC计算公式</h1>
<p>排序损失<span
class="math inline">\(\mathcal{l}_{rank}\)</span>被定义为</p>
<p><span class="math display">\[
\begin{aligned}
  \mathcal{l}_{rank} = \frac{1}{m^+m^-}\sum_{x^+\in D^+}\sum_{x^-\in
D^-}\left(\mathbb{I}(f(x^+)&lt;f(x^-)) +
\frac{1}{2}\mathbb{I}(f(x^+)=f(x^-))\right)
\end{aligned}
\]</span></p>
<p>对于一个ROC图，我们有如下关系： <span class="math display">\[
\text{AUC}=1-\mathcal{l}_{rank}
\]</span></p>
<p>（代入理想模型和随机模型，发现是对的。。）</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>柯柯的画</title>
    <url>/%E6%9F%AF%E6%9F%AF%E7%9A%84%E7%94%BB/</url>
    <content><![CDATA[<h1 id="阿贝多">阿贝多</h1>
<p><img src="/images/abeiduo.jpg" /></p>
<blockquote>
<p>玩原神的时候被阿贝多的美貌感动到了，想当阿贝多的狗😍</p>
</blockquote>
<p><strong>作者</strong>：柯柯，软院小仙男</p>
<p><strong>人物</strong>：阿贝多——原神</p>
]]></content>
      <categories>
        <category>展厅</category>
      </categories>
      <tags>
        <tag>绘画</tag>
        <tag>柯柯</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的博客！</title>
    <url>/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%81/</url>
    <content><![CDATA[<p>这是我的第一篇博客</p>
<p>以后会经常在这里记录一些我的学习经历</p>
<p>包括各种技术的踩坑之旅</p>
<p><strong>加油</strong></p>
<p><strong>頑張って！</strong>❤</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
  </entry>
  <entry>
    <title>测试</title>
    <url>/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1
id="这是一个超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长的一级标题">这是一个超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长的一级标题</h1>
<h2
id="这是一个超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长的二级标题">这是一个超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长的二级标题</h2>
<h3
id="这是一个超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长的三级标题">这是一个超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长超级长的三级标题</h3>
<h1 id="表格测试">表格测试</h1>
<table>
<thead>
<tr class="header">
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>甲</td>
<td>乙</td>
<td>丙</td>
</tr>
</tbody>
</table>
<h1 id="latex测试"><span class="math inline">\(\LaTeX\)</span>测试</h1>
<p>行内<span class="math inline">\(f(x)=\sin(x)\)</span>。</p>
<p>公式块 <span class="math display">\[
\begin{aligned}
    \sum_f E_{ote}(\mathcal{L}_a|X,f)&amp;=\sum_f\sum_h\sum_{x\in
\mathcal{X}-X}P(x)\mathbb{I}(h(x)\ne f(x))P(h|X,\mathcal{L}_a)\\
    &amp;=\sum_{x\in\mathcal{X}-X}P(x)\sum_hP(h|X,\mathcal{L}_a)\sum_f\mathbb{I}(h(x)\ne
f(x))\\
    &amp;=\sum_{x\in
\mathcal{X}-X}P(x)\sum_hP(h|X,\mathcal{L}_a)\frac{1}{2}2^{|\mathcal{X}|}\\
    &amp;=\frac{1}{2}2^{|\mathcal{X}|}\sum_{x\in
\mathcal{X}-X}P(x)\sum_hP(h|X,\mathcal{L}_a)\\
    &amp;=\frac{1}{2}2^{|\mathcal{X}|}\sum_{x\in \mathcal{X}-X}P(x)\\
\end{aligned}
\]</span></p>
<h1 id="toc测试">TOC测试</h1>
<h1 id="一级标题1">一级标题1</h1>
<h2 id="二级标题1">二级标题1</h2>
<h3 id="三级标题1">三级标题1</h3>
<h3 id="三级标题2">三级标题2</h3>
<h3 id="三级标题3">三级标题3</h3>
<h3 id="三级标题4">三级标题4</h3>
<h2 id="二级标题2">二级标题2</h2>
<h3 id="三级标题">三级标题</h3>
<h4 id="四级标题">四级标题</h4>
<h5 id="五级标题">五级标题</h5>
<h6 id="六级标题">六级标题</h6>
<p><strong>加粗</strong></p>
<p>正文</p>
<p><em>斜体</em></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>配置hexo博客，并更换多种主题</title>
    <url>/%E9%85%8D%E7%BD%AEhexo%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%B9%B6%E6%9B%B4%E6%8D%A2%E5%A4%9A%E7%A7%8D%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h1 id="hexo博客的基本维护方式">hexo博客的基本维护方式</h1>
<p>搭建过程可参考<a
href="https://blog.csdn.net/ai_green/article/details/121675790">hexo博客搭建教程</a>。</p>
<p>hexo提供了便捷的构建、部署功能。在本地添加了新的markdown日志或者图片之后，只需执行如下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除已有的构建目录，默认为public</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建新的静态文件，g是generate的缩写</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一条命令直接部署，d是deploy的缩写</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>就会把本地的public文件夹push到对应的github仓库，并将网站自动部署到
<code>&#123;github用户名&#125;.github.io</code>。</p>
<p>此外，如果想要维护本地源文件，还可以单独创建一个私有github仓库，用于存放source文件中的源文件等等。</p>
<p>（已弃用，请看<a
href="https://lulu010722.cn/2022/09/18/%E5%85%B3%E4%BA%8Earcher%E4%B8%BB%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AE/">进阶配置</a>）</p>
<p><br></p>
<h1 id="配置hexo">配置hexo</h1>
<p>hexo的默认在配置文件是根目录下的<code>_config.yml</code>，称之为<strong>hexo配置文件</strong>。更改其中的属性，可以改变网页的默认文本和样式。</p>
<p>其中的theme项默认的值是auto，我们可以更改这一个属性的值，来更换不同主题。</p>
<p><br></p>
<h1 id="下载并配置主题">下载并配置主题</h1>
<p>要更换主题，需要在<a
href="https://hexo.io/themes/">hexo主题网站</a>选择喜欢的主题进行下载安装。</p>
<p>有两种方式。</p>
<p><strong>第一种（所有主题均支持）</strong>：将主题对应的仓库克隆到<code>/themes/&#123;主题名&#125;</code>文件夹下。例如，对于archer主题，可以执行如下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--depth=1表示，仅克隆最近一次commit</span></span><br><span class="line">git clone https://github.com/fi3ework/hexo-theme-archer.git themes/archer --depth=1</span><br></pre></td></tr></table></figure>
<p>克隆完成后，在<code>archer</code>文件夹的配置文件<code>_config.yml</code>中进行修改。</p>
<p><strong>注意！每个主题的仓库中都有一个<code>_config.yml</code>文件，称之为主题配置文件，与根目录下的<code>_config.yml</code>文件是不同的。</strong></p>
<p><strong>第二种（仅部分主题支持）</strong>：通过npm下载主题对应的依赖包。例如，对于keep主题而言，可以执行如下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-keep --save</span><br></pre></td></tr></table></figure>
<p>下载完成后，themes文件夹下不会出现对应的文件夹。若想对该主题进行配置，需要在hexo配置文件中，添加theme_config项，在theme_config属性后，添加主题配置属性。</p>
<p><br></p>
<h1 id="配置加载原理推测">配置加载原理（推测）</h1>
<p>首先，hexo加载根目录下的<strong>hexo配置文件</strong>，若发现theme的值不为默认的auto，则顺序进行如下过程：</p>
<p>对于<strong>第一种</strong>方式下载的主题：</p>
<ol type="1">
<li>在根目录中搜索<code>_config.&#123;主题名称&#125;.yml</code>文件，如果找到，则继续加载该配置文件中的内容，否则，</li>
<li>在<code>themes</code>文件夹中寻找主题名称对应的文件夹，如果找到，则加载<code>themes/&#123;主题名称&#125;/_config.yml</code>文件。若文件夹或者配置文件没有找到，则会报错。</li>
</ol>
<p>对于<strong>第二种</strong>方式下载的主题：</p>
<p>在<strong>hexo配置文件</strong>中寻找<code>theme_config</code>属性，并加载。</p>
<p><br></p>
<h1 id="踩过的坑">踩过的坑</h1>
<ol type="1">
<li>首先，更改了主题名称之后，<strong>一定要清除原来的构建目录并重新构建</strong>，也就是运行hexo
clean &amp;&amp; hexo g。</li>
<li>不能手动在github的仓库设置里面添加custom
domain，因为这样每次部署后，自定义的域名都会丢失。需要在<code>source/</code>下创建一个<strong>CNAME</strong>的文件，将自定义域名写入。</li>
<li>如果添加了文件等静态资源，需要hexo
g。否则部署之后，服务器无法获得图片等静态资源文件。</li>
</ol>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
  </entry>
  <entry>
    <title>解封了，吗？</title>
    <url>/%E8%A7%A3%E5%B0%81%E4%BA%86%EF%BC%8C%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<p>如果不算开学第一天上午那可怜的一节课的话，时至今日，贵交学子已经至少半年没有上过一节正常的线下课程了。</p>
<p>然而我上线下课程第一天的感受却是，不习惯。</p>
<p>各个课程均有几节课的延迟，现在转接到线下，根本无所适从。</p>
<p>当初强迫线上骂声一片，现在强迫线下甚至也有骂声一片。</p>
<p>这一切都是一场游戏吧。</p>
]]></content>
      <categories>
        <category>校园</category>
      </categories>
      <tags>
        <tag>校园</tag>
        <tag>线下课程</tag>
      </tags>
  </entry>
  <entry>
    <title>随便写写</title>
    <url>/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/</url>
    <content><![CDATA[<blockquote>
<p><em>与其称之为”随笔“，倒不如称之为”随键“</em></p>
<p><em>旁人有感而发，大都落笔成文</em></p>
<p><em>而我不同，我触键成章</em></p>
</blockquote>
<h1 id="又一次鄙视自己的灵魂">又一次鄙视自己的灵魂</h1>
<p>躺在床上，虽然很困，但是仍执着地拿着手机的时候，其实是在期望着在偌大的网络世界找到什么。</p>
<p>不过我不幸运，要么什么也找不到，要么自以为找到了，但是一觉醒来，生活和自己，都没变。</p>
<p>偶然想起，三四年前，给一位我特别尊敬的老师写过的一首诗。</p>
<blockquote>
<center>
<h2 id="赠师普">赠师普</h2>
<blockquote>
<p>三月末，高考将至，颇念吾师增普旧恩，特献丑赋诗一篇，兼与同门高徒兴达，瑞嵩，家鑫，子扬等共勉</p>
</blockquote>
<p>十载光华空回轮，</p>
<p>一朝幸甚入师门。</p>
<p>要问师普何服我，</p>
<p>学富才高撼余心。</p>
<p>忽叹往岁虚无度，</p>
<p>幸觉宏图尚可伸。</p>
<p>今当远走高飞去，</p>
<p>莫敢寸阴忘师恩。</p>
</blockquote>
<p>如果细读，不难发现，平仄构造最工整的一联，是颈联。</p>
<p>三年前的我，不会想到，今天的他自己，面对着这十四个字，百感交集。</p>
<p>“虚无”二字，像是带着线的针，先后扎进我的各个求学阶段，缝合在一起，聚成了我的青春。</p>
<p><br></p>
<blockquote>
<p>第一次，当它本可进取时，却故作谦卑；</p>
<p>第二次，当它在空虚时，用爱欲来填充；</p>
<p>第三次，在困难和容易之间，它选择了容易；</p>
<p>第四次，它犯了错，却借由别人也会犯错来宽慰自己；</p>
<p>第五次，它自由软弱，却把它认为是生命的坚韧；</p>
<p>第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副；</p>
<p>第七次，它侧身于生活的污泥中，虽不甘心，却又畏首畏尾。</p>
<p><br></p>
<p><em>——纪伯伦《我曾七次鄙视自己的灵魂》</em></p>
</blockquote>
<p>也许这就是好的作品吧，在你还没有静心拜读的时候，他就能以这种直白的方式，使远隔重洋，穿越时空的我们，同频共振。</p>
<p>初看，自觉最贴合我的应该是第二条；又看，又觉得这一、三、四难道说的不是我？</p>
<p><br></p>
<p>我以为，构成了我的，绝不仅仅是出生时被基因刻下的属性，而是在时间的坐标轴上，所遇过的人和事，不同程度地决定了我当下的状态。人们总是错觉地认为，自己的经历太独特，如果条件允许，可将自己的前半生写成小说。我更倾向于认为，其实人遇到的每一件单独的事都并不独特，而是这些事的组合具有随机性，是千变万化的，从而塑造了每一个人的无限可能。对于我，这个组合是：</p>
<ol type="1">
<li>作为家族中我辈唯一的男孩，被生养在一个重男轻女的家庭；</li>
<li>在祖辈和父辈的溺爱中长大；</li>
<li>在学业上一帆风顺，但是并不是因为充分的拼搏和努力，也许只是一点聪明劲儿和运气；</li>
<li>溺爱的同时，又缺爱，至少是缺乏我所希望的关爱；</li>
<li>幼年天生丽质，被捧杀为“班草”，如今面色蜡黄，百孔千疮。</li>
</ol>
<p>好像一场化学反应的五种原料，被放进了时间的熔炉，任凭他们彼此碰撞，时而奇光四射，时而烟雾缭绕，也不管最后出落成了什么，它都原原本本地把我展现出来。这些都不是我能控制的，但却被生硬地加进了我的人生。</p>
<p>我不能重来，我只能继续向这个熔炉里，继续添加，纵使不知是一剂稳定剂还是催化剂，我也只能，继续添加。</p>
<p>因为在解构完成之后，总要继续建构，否则就是顾影自怜，亦或是孤芳自赏了罢。</p>
<p>笔者实在不知所云，看官见谅。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>随键</tag>
      </tags>
  </entry>
  <entry>
    <title>我的雷神🤗</title>
    <url>/%E6%88%91%E7%9A%84%E9%9B%B7%E7%A5%9E%F0%9F%A4%97/</url>
    <content><![CDATA[<p><img src="/images/leishen.jpg" /></p>
<hr />
<p><img src="/images/leishen1.jpg" /></p>
<hr />
<p><img src="/images/leishen2.jpg" /></p>
]]></content>
      <categories>
        <category>展厅</category>
      </categories>
      <tags>
        <tag>手办</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统基础</title>
    <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>[TOC]</p>
<div
style="font-size: 50px; font-weight: bold; color: #777; margin: 22px 0; line-height: normal;">
第一部分 程序结构和执行
</div>
<h1 id="第一章-计算机系统漫游">第一章 计算机系统漫游</h1>
<h1 id="第二章-信息的表示和处理">第二章 信息的表示和处理</h1>
<h2 id="数据类型的转换">数据类型的转换</h2>
<h3 id="相同位数">相同位数</h3>
<p>以32位int和unsigned举例，基本原则是保持二进制表示不变，而将实际表示的数字调整。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">unsigned</span> b;</span><br><span class="line"></span><br><span class="line">a = <span class="number">0xffffffff</span>; <span class="comment">// a = -1</span></span><br><span class="line">b = (<span class="type">int</span>)a;     <span class="comment">// b = 0xffffffff</span></span><br></pre></td></tr></table></figure>
<h3 id="不同位数">不同位数</h3>
<p>如果两个类型的长度和符号都不相同，则遵循先扩展/收缩长度，再进行符号转换。</p>
<p><strong>扩展无符号</strong>：补零</p>
<p><strong>扩展有符号</strong>：补最高位</p>
<p><strong>截断无符号</strong>：直接截断</p>
<p><strong>截断有符号</strong>：直接截断</p>
<h2 id="ieee浮点数表示">IEEE浮点数表示</h2>
<p><span class="math inline">\(V=(-1)^s\times M\times 2^E\)</span></p>
<ul>
<li><p><span class="math inline">\(s\)</span>: 符号位；</p></li>
<li><p><span class="math inline">\(M\)</span>: 尾数；</p></li>
<li><p><span class="math inline">\(E\)</span>: 阶码。</p></li>
</ul>
<p>在计算机中，我们也按照这三个部分来表示。</p>
<ul>
<li>一个单独符号位<span class="math inline">\(s\)</span>。</li>
<li><span class="math inline">\(k\)</span>位阶码字段<span
class="math inline">\(e=e_{k-1}\cdots e_1e_0\)</span>编码阶码<span
class="math inline">\(E\)</span>。</li>
<li><span class="math inline">\(n\)</span>位小数字段<span
class="math inline">\(f=f_{n-1}\cdots f_1f_0\)</span>编码尾数<span
class="math inline">\(M\)</span>，但是编码对应的值与<span
class="math inline">\(E\)</span>是否等于零有关（格式化与非格式化表示）。</li>
</ul>
<p>共有三种情况</p>
<ol type="1">
<li>格式化，<span
class="math inline">\(e\)</span>的各位不为全0页不为全1。<span
class="math inline">\(E=e-Bias\)</span>, <span
class="math inline">\(e\)</span>无符号数，Bias=<span
class="math inline">\(2^{k-1}-1\)</span>，<span
class="math inline">\(M=1+f\)</span>。</li>
<li>非格式化，此时<span class="math inline">\(e\)</span>各位全为0。<span
class="math inline">\(E=1-Bias\)</span>，<span
class="math inline">\(M=f\)</span>。</li>
<li>特殊值，此时<span
class="math inline">\(e\)</span>各位全为1。如果<span
class="math inline">\(f\)</span>的各位全为0，则表示无穷大，否则表示NaN。</li>
</ol>
<h2 id="浮点之间浮点与整形的转换">浮点之间，浮点与整形的转换</h2>
<ol type="1">
<li>int-&gt;float，不会溢出，但是可能会损失精度；</li>
<li>int或float-&gt;double，不会溢出也不会损失精度；</li>
<li>double-&gt;float，有可能会溢出为<span
class="math inline">\(+\infty\)</span>或者<span
class="math inline">\(-\infty\)</span>，若不溢出，也可能损失精度；</li>
<li>float或double-&gt;int，向零取整，值可能会溢出，但是并未规定处理方式。</li>
</ol>
<hr />
<h1 id="第三章-程序的机器级表示">第三章 程序的机器级表示</h1>
<h1 id="第四章-处理器体系结构">第四章 处理器体系结构</h1>
<h1 id="第五章-优化程序性能">第五章 优化程序性能</h1>
<h1 id="第六章-储存器层次结构">第六章 储存器层次结构</h1>
<hr />
<div
style="font-size: 50px; font-weight: bold; color: #777; margin: 22px 0; line-height: normal;">
第二部分 在系统上运行程序
</div>
<h1 id="第七章-链接">第七章 链接</h1>
<h2 id="基本流程">基本流程</h2>
<pre class="mermaid">flowchart TB;
A(main.c源代码) --> cpp预处理器 --> B(main.i中间文件) --> cc1编译器 --> C(main.s汇编文件) --> as汇编器 --> D(main.o可重定位目标文件) --> ld链接器 --> E(main可执行目标文件) --> loader加载器 --> F(运行)</pre>
<h2 id="静态链接">静态链接</h2>
<p>可重定向目标文件格式</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 86%" />
</colgroup>
<thead>
<tr class="header">
<th>部分</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ELF头</td>
<td>文件的元信息，包括ELF头本身大小，目标文件类型（可重定向，可执行，共享），机器类型，节头部表的偏移，节头部表中的条目大小和数量。</td>
</tr>
<tr class="even">
<td>.text</td>
<td>以编译程序的机器代码。</td>
</tr>
<tr class="odd">
<td>.rodata</td>
<td>只读数据，例如printf语句中的格式化字符串和switch语句的跳转表。</td>
</tr>
<tr class="even">
<td>.data</td>
<td>已初始化的全局和静态C变量。局部C变量保存于栈中，既不存在于.data，也不存在于.bss。</td>
</tr>
<tr class="odd">
<td>.bss</td>
<td>未初始化的静态C变量，以及所有被初始化为0的全局和静态C变量。区分是否初始化为0是为了节省空间。未初始化的全局变量将被放在COMMON伪节。</td>
</tr>
<tr class="even">
<td>.symtab</td>
<td>符号表，存放程序中定义和引用的函数和全局变量的信息。和编译器的符号表不同，.symtab不包含局部变量。</td>
</tr>
<tr class="odd">
<td>.rel.text</td>
<td>.text节中位置的列表，当链接器将目标文件和其他文件组合时，需要修改这些位置。可执行目标文件不需要重定位信息，所以一般没有该条目。</td>
</tr>
<tr class="even">
<td>.rel.data</td>
<td>被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已经初始化的全局变量，如果他的初始值是一个全局变量的地址或者外部定义函数的地址，都需要被修改。</td>
</tr>
<tr class="odd">
<td>.debug</td>
<td>调试符号表，条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及C源文件。只有以-g选项调用编译器时，才会得到这张表。</td>
</tr>
<tr class="even">
<td>.line</td>
<td>C源程序中行号和.text节中机器指令之间的映射，只有以-g选项调用编译器时，才会得到这张表。</td>
</tr>
<tr class="odd">
<td>.strtab</td>
<td>一个字符串表，内容包括.symtab和.debug中的符号表，以及节头部中的节名字。是以null结尾的字符串序列。</td>
</tr>
<tr class="even">
<td>节头部表</td>
<td>描述目标文件。</td>
</tr>
</tbody>
</table>
<h2 id="符号和符号表">符号和符号表</h2>
<p>可重定向目标文件m的.symtab中有三种不同的符号：</p>
<ul>
<li>由模块m定义并能被其他模块访问的<strong>全局符号</strong>，全局链接器符号对应于<strong>非静态C函数和全局变量</strong>。</li>
<li>由其他模块定义并被m模块引用的的全局符号，称为<strong>外部符号</strong>，对应于在其他文件中定义的<strong>非静态C函数和全局变量</strong>。</li>
<li>只被模块m定义和引用的<strong>局部符号</strong>，对应于<strong>静态C函数和静态全局变量</strong>。</li>
</ul>
<p>动态局部变量和全局静态变量有区别，前者由栈管理，链接器只考虑后者。</p>
<p><strong>但是</strong>，局部变量也可以被声明为静态。此时它是不被栈管理的。相反，编译器会在.data或者.bss中为每个定义分配空间，并在符号表中创建有唯一名称的链接器符号。</p>
<p>符号表是由一种结构体构成的数组，结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> name;        <span class="comment">// 在字符串表中的字节偏移，指向以null结尾的字符串名字。</span></span><br><span class="line">    <span class="type">char</span> type:<span class="number">4</span>,     <span class="comment">// 区分数据和函数。</span></span><br><span class="line">    	 binding:<span class="number">4</span>;  <span class="comment">// 区分本地和全局。</span></span><br><span class="line">    <span class="type">char</span> reserved;</span><br><span class="line">    <span class="type">short</span> section;   <span class="comment">// 符号所在节。</span></span><br><span class="line">    <span class="type">long</span> value;      <span class="comment">// 符号的地址。在可重定向目标文件中，是距定义目标的节起始位置的偏移，而对于可执行目标文件来说，是一个绝对运行时地址。</span></span><br><span class="line">    <span class="type">long</span> size;       <span class="comment">// 目标的大小，单位为字节。</span></span><br><span class="line">&#125; Elf64_Symbol;</span><br></pre></td></tr></table></figure>
<p>符号表中的一个条目，还可以表示一个节，也可以用来表示原始文件路径名。</p>
<h3 id="伪节">伪节</h3>
<p>除了表中列出的节之外，还有三个伪节，在节头部表中没有条目。伪节仅存在于可重定向目标文件。</p>
<ul>
<li><strong>ABS</strong>：表示不该被重定向的符号；</li>
<li><strong>UNDEF</strong>：表示未定义的符号，也就是在本目标模块中引用，但是在其他地方定义的符号；</li>
<li><strong>COMMON</strong>：表示还未被分配位置的未初始化的数据目标。此时，value字段给出对齐要求，size指的是最小的大小。</li>
</ul>
<h3 id="common和.bss的区别">COMMON和.bss的区别。</h3>
<p>COMMON存放未初始化的全局变量（也就是弱符号）；</p>
<p>.bss存放未初始化的静态变量，以及初始化为0的全局和静态变量。</p>
<p>造成这一区分的主要原因是，编译器允许不同模块中有同名的符号。</p>
<h2 id="符号解析">符号解析</h2>
<p><strong>强符号</strong>：函数和已经初始化的全局变量；</p>
<p><strong>弱符号</strong>：未初始化的全局变量。</p>
<p>三条规则</p>
<ol type="1">
<li>不允许有同名的强符号；</li>
<li>如果有强符号和弱符号同名，则选择强符号；</li>
<li>如果若干弱符号同名，则随意选择一个。</li>
</ol>
<h2 id="静态库">静态库</h2>
<p>多个标准可重定向目标文件，可以打包形成一个归档文件，以.a后缀名结尾，又称为<strong>静态库</strong>。</p>
<p>在使用gcc命令进行编译的时候，需要将用到的静态库显式地添加到命令行。</p>
<p>例如<code>gcc main.c /usr/lib/libm.a /usr/lib/libc.a</code>，而libc.a是被默认链接地，所以并不需要指出。</p>
<p>静态库的连接顺序是有所谓的。未定义的符号所在模块，必须出现在定义模块之前。</p>
<h2 id="重定位">重定位</h2>
<p>链接器知道了.text和.data的确切大小，可以进行地址的重定位。</p>
<ol type="1">
<li>重定位节和符号定义。将所有模块的同种节合成一个，例如将所有模块的.data节合成一个大的.data节，输出到可执行目标文件的.data节。然后链接器为每个聚合节，聚合节中的每一个原始节，和节中出现的符号分配运行时内存地址。</li>
<li>重定位节中的符号引用。修改代码和数据节中对每个符号的引用。这依赖于.rel.text和.rel.data两个重定位节。</li>
</ol>
<p>代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。</p>
<p>条目格式如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> offset;    <span class="comment">// 要被修改的引用相对于节的偏移。</span></span><br><span class="line">    <span class="type">long</span> type:<span class="number">32</span>,   <span class="comment">// 重定位类型，告诉链接器如何修改。</span></span><br><span class="line">         symbol:<span class="number">32</span>; <span class="comment">// 该引用指向的符号。</span></span><br><span class="line">    <span class="type">long</span> addend;    <span class="comment">// 一些类型的重定位需要使用该信息来修改偏移量。</span></span><br><span class="line">&#125; Elf64_Rela;</span><br></pre></td></tr></table></figure>
<p>ELF定义了32种不同的重定位模式。</p>
<ul>
<li><strong>R_X86_64_PC32</strong>：32位PC相对地址；</li>
<li><strong>R_X86_64_32</strong>：32位绝对地址。</li>
</ul>
<p>这两种类型支持x86-64小型代码模型，即假设代码和数据总体大小小于2GB。</p>
<h2 id="可执行目标文件">可执行目标文件</h2>
<table>
<thead>
<tr class="header">
<th>部分</th>
<th>段属性</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>ELF头</td>
<td>只读内存段（代码段）</td>
<td></td>
</tr>
<tr class="even">
<td>段头部表</td>
<td>只读内存段</td>
<td>将连续的文件节映射到运行时的内存段</td>
</tr>
<tr class="odd">
<td>.init</td>
<td>只读内存段</td>
<td></td>
</tr>
<tr class="even">
<td>.text</td>
<td>只读内存段</td>
<td></td>
</tr>
<tr class="odd">
<td>.rodata</td>
<td>只读内存段</td>
<td></td>
</tr>
<tr class="even">
<td>.data</td>
<td>读写内存段（数据段）</td>
<td></td>
</tr>
<tr class="odd">
<td>.bss</td>
<td>读写内存段</td>
<td></td>
</tr>
<tr class="even">
<td>.symtab</td>
<td>不加载到内存</td>
<td></td>
</tr>
<tr class="odd">
<td>.debug</td>
<td>不加载到内存</td>
<td></td>
</tr>
<tr class="even">
<td>.line</td>
<td>不加载到内存</td>
<td></td>
</tr>
<tr class="odd">
<td>.strtab</td>
<td>不加载到内存</td>
<td></td>
</tr>
<tr class="even">
<td>节头部表</td>
<td>不加载到内存</td>
<td>描述目标文件的节</td>
</tr>
</tbody>
</table>
<h3 id="程序头部表">程序头部表</h3>
<p>描述了将代码段加载到内存的映射关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">只读段</span><br><span class="line">LOAD off    0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21</span><br><span class="line">     filesz 0x000000000000069c memsz 0x000000000000069c flags r-x</span><br><span class="line"></span><br><span class="line">读写段</span><br><span class="line">LOAD off    0x0000000000000df8 vaddr 0x0000000000600df8 paddr 0x0000000000600df8 align 2**21</span><br><span class="line">     filesz 0x0000000000000228 memsz 0x0000000000000230 flags rw-</span><br></pre></td></tr></table></figure>
<p>filesz和memsz不一致的原因在于，.bss在目标文件中是不需要占用空间的，但是在内存中需要为其留出位置并初始化为0。</p>
<p>off和vaddr要求对齐，即<span class="math inline">\(\text{vaddr}\pmod
{\text{align}}=\text{off}\pmod
{\text{align}}\)</span>。这种要求的原因，与虚拟内存的组织方式有关。</p>
<h2 id="加载可执行目标文件">加载可执行目标文件</h2>
<p>在命令行中执行内置命令或用<code>./prog</code>来执行一个可执行文件，或者调用`<code>execve</code>函数，都可以调用加载器（loader）。</p>
<h2 id="动态链接">动态链接</h2>
<p>静态库的一个问题是，所有进程都会加载相同的标准静态库函数，造成内存的极大浪费。</p>
<p><strong>共享库</strong>在运行或加载时，加载到任意的内存位置，并和一个在内存中的程序链接起来。</p>
<p>共享库也叫共享目标，在Linux中以.so文件后缀结尾，在Windows中则是DLL（动态链接库）。</p>
<p>两种不同的共享方式：</p>
<ol type="1">
<li>一个库只对应一个.so文件，所有引用该库的文件共享.text和.data中的数据，而不用嵌入到引用模块的可执行目标文件中；</li>
<li>在内存中，共享库的.text节的一个副本可以被不同的正在运行的进程共享。</li>
</ol>
<pre class="mermaid">flowchart TB;
A(main.c) & B(vector.h) --> a["翻译器(cpp, cc1, as)"] --> C(可重定位目标文件main.o)
C & D(libc.so\nlibvector.so) --> b["链接器(ld)"] --> E("部分链接地可执行目标文件prog1") --> c["加载器(execve)"]
c & F("libc.so\nlibvector.so") --> d["动态链接器(ld-linux.so)"] --> G("完全链接的可执行目标文件prog2")</pre>
<h2 id="位置无关代码pic">位置无关代码（PIC）</h2>
<p>如何在多个进程中共享一个程序副本？</p>
<p>如果为每一个共享库都分配一个固定的地址空间，那么弊端很多，主要是难于管理，并且也有很大浪费。</p>
<p>可加载而无需重定向的代码称之为<strong>位置无关代码（Position-Independent
Code）</strong>。</p>
<h3 id="全局偏移量表got">全局偏移量表（GOT）</h3>
<p>首先，编译器在.data开始的地方创建一个<strong>全局偏移量表（Global
Offset
Table）</strong>。每个被该模块引用的全局数据目标（过程或者全局变量）都有一个8字节的条目。同时编译器还为GOT中的每一个条目生成一个重定向记录，由于代码段和数据段的间隔是不变的，编译器可以使用PC相对寻址来重定位。</p>
<h3 id="过程链接表plt">过程链接表（PLT）</h3>
<p>为了避免动态链接在加载时，对成百上千个不需要的符号进行重定位，GNU提出了<strong>延迟绑定</strong>。延迟绑定需要使用GOT和<strong>过程连接表（Procedure
Linkage
Table）</strong>两个数据结构。如果一个目标模块调用了共享库中定义的任何函数，那么他就有GOT和PLT。GOT是数据段的一部分，PLT是代码段的一部分。</p>
<h2 id="库打桩机制">库打桩机制</h2>
<h1 id="第八章-异常控制流">第八章 异常控制流</h1>
<h2 id="异常">异常</h2>
<p>异常的发生可能与当前执行的指令有关，例如当前指令发生了一些缺页错误，或者尝试除零；也可能与当前指令没有关系，例如定时器到时，或者IO操作完成。</p>
<p>当程序检测到有异常时，会通过<strong>异常表</strong>来进行间接的函数调用，到一个专门处理这些事件的操作系统子程序（异常处理程序）。处理完成后，根据异常事件的类型，会发生三种情况。</p>
<ol type="1">
<li>将控制返回<span
class="math inline">\(I_{curr}\)</span>，重新执行；</li>
<li>将控制返回<span
class="math inline">\(I_{next}\)</span>，跳过之前的指令；</li>
<li>终止被中断的程序。</li>
</ol>
<h3 id="异常处理">异常处理</h3>
<p>系统为每种异常都分配了一个异常号码，有一些来自于处理器的设计者，有一些来自于操作系统内核。</p>
<p>系统在启动时，操作系统会分配并初始化一张异常表，每个条目都指向对应异常的处理函数的地址。</p>
<p>异常表的起始地址存放在名为<strong>异常表基址寄存器</strong>的特殊寄存器中。</p>
<p>异常处理函数的调用与普通函数调用有一些区别：</p>
<ol type="1">
<li>将当前函数的返回地址压栈的时候，根据异常类型，要确定是压入当前指令地址，还是下一个指令的地址；</li>
<li>处理函数会把一些额外的处理器状态压栈，但是栈有内核栈和用户栈的区别。处理函数由于处于内核态，则压入内核栈，同时它也对所有系统资源具有完全访问权限。</li>
</ol>
<h3 id="异常种类">异常种类</h3>
<ul>
<li>中断（interrupt）</li>
<li>陷阱（trap）</li>
<li>故障（fault）</li>
<li>终止（abort）</li>
</ul>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 24%" />
<col style="width: 42%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>类别</th>
<th>原因</th>
<th>异步/同步</th>
<th>返回行为</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>中断</td>
<td>来自IO设备的信号</td>
<td>异步（与当前指令无关的异常）</td>
<td>总是返回下一条指令</td>
</tr>
<tr class="even">
<td>陷阱</td>
<td>有意的异常</td>
<td>同步（当前指令的直接产物）</td>
<td>总是返回下一条指令</td>
</tr>
<tr class="odd">
<td>故障</td>
<td>可能恢复的异常</td>
<td>同步（当前指令的直接产物）</td>
<td>可能返回当前地址</td>
</tr>
<tr class="even">
<td>终止</td>
<td>不可恢复的异常</td>
<td>同步（当前指令的直接产物）</td>
<td>不会返回</td>
</tr>
</tbody>
</table>
<p><strong>中断</strong></p>
<p>IO设备会异步地向CPU的一个引脚发送信号。</p>
<p>CPU会在<strong>处理完当前指令之后</strong>调用异常处理器，而不是直接打断执行到中间状态的当前指令，于是原来的进程就像没有受到中断一样，继续执行下一条指令。</p>
<p><strong>陷阱和系统调用</strong></p>
<p>是有意为之的异常，主要是用来进行系统调用，例如调用系统层的read，write，fork等等函数。</p>
<p>处理器提供了一个特殊的<code>syscall n</code>指令，n代表系统函数的编号。</p>
<p><strong>故障</strong></p>
<p>用户程序发生了一个错误情况，触发故障处理函数。如果处理函数能够修复故障，则会返回出现故障的用户指令重新执行，否则，处理函数将会直接在<strong>内核态</strong>发送一个新的终止异常，结束用户程序。</p>
<p><strong>终止</strong></p>
<p>终止是不可修复的致命错误，通常是一些硬件错误。</p>
<h3 id="linuxx86-64系统异常">Linux/x86-64系统异常</h3>
<p>有256种异常，0-31号由Intel的设计师们定义，因此对于任何x86-64的机器，这些异常都是一样的，32-255号是由操作系统定义的中断和陷阱。</p>
<p><strong>Linux故障和终止举例</strong></p>
<p><em>除法错误</em>：编号0，不会恢复，Linux
shell通常会报“浮点异常（Floating exception）”的异常信息。</p>
<p><em>一般保护故障</em>：编号13，有许多原因，但通常是由于程序引用了一个未定义的虚拟内存区域，例如访问空指针，或尝试修改一个只读片段。不会恢复，Linux
shell通常报告为“段故障（Segmentation fault）”。</p>
<p><em>缺页</em>：编号14，与虚拟内存的管理有关。</p>
<p><em>机器检查</em>：编号18，硬件错误。</p>
<p><strong>Linux系统调用</strong></p>
<p>Linux提供了上百个系统调用，每个都对应于一个整数号，对应于内核中的一个跳转表（<strong>注意该跳转表与异常表并不相同</strong>）。</p>
<p>调用<code>syscall</code>指令即可进入内核态执行系统函数。在开始前，需要将编号存入%rax寄存器，并将可能用到的参数依次存入%rdi、%rsi、%rdx、%rcx、%r8、%r9这六个寄存器中。系统函数无法使用栈传递更多的参数，于是一个系统函数最多只有六个参数。</p>
<h2 id="进程">进程※</h2>
<p>提供一种假象，让我们的程序独占所有计算机资源。</p>
<p>进程提供了两个关键抽象：</p>
<ul>
<li>一个独立的逻辑控制流；</li>
<li>一个私有的地址空间。</li>
</ul>
<h3 id="私有地址空间">私有地址空间</h3>
<p>一般而言，一个进程所在的内存字节是不能被其他进程进行读写的，也就是所谓私有。</p>
<p>每个进程的地址空间都有相同的结构。</p>
<p><img src="/images/ics1.png" /></p>
<h3 id="用户态和内核态">用户态和内核态</h3>
<p>处理器必须限制一个应用可以执行的指令和可以访问的地址空间范围。通常用一个模式位来提供这种功能。当设置了该模式位时，系统处于内核态，可以访问内存中的任何位置。</p>
<p>在用户态中，如果直接执行特权指令，例如停止处理器，改变模式位，发起IO操作，或者访问内核态的代码和数据，都会直接导致保护故障。用户必须通过系统调用接口来间接的调用内核数据和代码。</p>
<p>用户态进入内核态的<strong>唯一方法</strong>是触发异常。</p>
<p>Linux提供了一种/proc文件系统，他允许用户访问内核数据结构的内容，例如CPU类型，某个进程所使用的内存段。</p>
<h3 id="上下文切换">上下文切换</h3>
<p>以进程A进行read系统调用为例。</p>
<ol type="1">
<li>进程A通过系统调用触发陷阱异常，进入内核态；</li>
<li>内核在执行了一部分陷阱处理逻辑之后，将需要等待磁盘的返回，此时它将进行上下文切换，切换到进程B的内核态；</li>
<li>系统进入进程B的用户态并执行代码；</li>
<li>进程B在执行过程中，受到了来自磁盘的中断，表示数据已经读取成功；</li>
<li>进程B进入内核态，随后内核将上下文切换回A进程；</li>
<li>系统进入进程A的用户态，继续执行剩余的用户代码。</li>
</ol>
<h3 id="系统调用的错误">系统调用的错误</h3>
<p>和用户函数一样，系统调用也可能出现错误。此时通常会返回-1，并设置全局整数变量<code>errno</code>来表示出了什么问题。</p>
<p>通过<code>strerror(errno)</code>函数，我们可以将errno对应的错误信息打印出来。</p>
<h2 id="进程控制">进程控制※</h2>
<p>接下来将复习Unix的进程控制函数，数量较多。</p>
<h3 id="进程id">进程ID</h3>
<p>每个进程都有一个正数进程ID。可以通过getpid获取，getppid则返回父进程的pid。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="创建和终止进程">创建和终止进程</h3>
<p>进程的状态有三种：</p>
<ul>
<li><strong>运行</strong>：或者正在执行，或者在等待内核再一次切换上下文回来继续执行；</li>
<li><strong>停止</strong>：被挂起，且不会被调度。当收到SIGSTOP，SIGTSTP，SIGTTIN或者SIGTTOU等信号时，进程就会停止。当他收到SIGCONT信号时，程序再次回到运行状态；</li>
<li><strong>终止</strong>：程序永远的停止了，原因可能有三个：
<ol type="1">
<li>收到默认行为为终止进程的信号；</li>
<li>从主程序返回；</li>
<li>调用了<code>exit</code>函数。</li>
</ol></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br><span class="line"><span class="comment">// 不返回。</span></span><br></pre></td></tr></table></figure>
<p>父进程可通过<code>fork</code>函数创建一个新的进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回：子进程为0，父进程为子进程PID；出错则返回-1。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>调用一次，返回两次，分别在父进程和子进程中。在父进程中，返回的是子进程的PID，在子进程中，返回0。通过这一特性，我们就可以区分当前进程是父进程还是子进程。</li>
<li>并发执行。进程一旦创建完毕，父子进程的执行是并发的，他们可能以任何可能的顺序交替执行。</li>
<li>相同但是独立的地址空间。<code>fork</code>函数执行完之后，两进程的地址空间及其内容是一样的，但是针对其进行的修改是完全独立的。</li>
<li>共享文件。子进程会继承父进程打开的所有文件。</li>
</ul>
<h3 id="进程回收">进程回收</h3>
<p>进程的三种状态之一是终止。但是终止并不意味着系统会将该进程所占用的资源立刻回收，清空，并释放。父进程需要主动地去回收它。一个终止但并未被回收的进程称之为僵尸进程。当父进程回收子进程时，内核可以将子进程的退出状态传递给父进程。</p>
<p>系统中的所有进程，都是init进程的子进程。init的PID是1，是所有进程的祖先，在系统启动时被内核创建，永远不会退出。</p>
<p>在一个进程退出时，如果他存在孤儿进程，则init会主动去收养该进程作为自己的子进程。如果一个父进程在退出时并未回收其僵尸子进程，则init会自动回收他们。但是，对于长时间不退出的进程，例如shell或者服务器，我们需要手动去回收其子进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statusp, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">// 返回：如果成功，则为子进程PID；如果options设置了WNOHANG则为0；其他为-1。</span></span><br></pre></td></tr></table></figure>
<p>该函数的行为<strong>比较复杂</strong>。</p>
<p><strong>默认情况下（options=0）</strong>，进程被挂起，直到其<em>等待集合</em>中的某一个子进程终止。</p>
<p><strong>修改等待集合</strong>，通过指定pid参数来控制。</p>
<ul>
<li><strong>pid&gt;0</strong>：等待PID=pid的进程返回。</li>
<li><strong>pid=-1</strong>：等待集合为父进程的所有子进程。</li>
</ul>
<p><strong>修改默认行为</strong>，通过修改options来控制。</p>
<ul>
<li><strong>WNOHANG</strong>：如果调用的时候，等待集合里面没有已经终止的子进程，则立即返回。</li>
<li><strong>WUNTRACED</strong>：除了等待终止，也等待停止。</li>
<li><strong>WCONTINUED</strong>：除了等待终止，也等待一个等待集合中被停止的进程被SIGCONT重新激活。</li>
</ul>
<p>可以将他们用或运算组合起来。</p>
<p><strong>检查已回收子进程的退出状态</strong></p>
<p>设<code>int status = *statusp;</code>（如果statusp非空）。</p>
<p><code>waitpid</code>会修改改指针指向的值，然后父进程可以用一些预定义的宏来获取信息。</p>
<ul>
<li><strong>WIFEXITED</strong>：如果子进程正常终止，则返回真。</li>
<li><strong>WEXITSTATUS</strong>：返回退出状态。</li>
<li><strong>WIFSIGNALED</strong>：如果子进程是因为一个未被捕获的信号终止的，则返回真。</li>
<li><strong>WTERMSIG</strong>：返回引起终止的信号编号。</li>
<li><strong>WIFSTOPPED</strong>：如果因为子进程停止而返回，则返回真。</li>
<li><strong>WSTOPSIG</strong>：返回引起子进程停止的信号编号。</li>
<li><strong>WIFCONTINUED</strong>：如果因为子进程重新运行而返回，则返回真。</li>
</ul>
<p><strong>错误返回</strong></p>
<p>如果没有子进程，则返回-1，并设置<code>errno</code>为<code>ECHILD</code>；如果<code>waitpid</code>被一个信号中断，则返回-1，并设置<code>error</code>为<code>EINTR</code>。</p>
<h3 id="进程休眠">进程休眠</h3>
<p>可以用<code>sleep</code>来让进程休眠指定时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="comment">// 返回：还要休眠的秒数。</span></span><br></pre></td></tr></table></figure>
<p><code>sleep</code>如果达成了设置的休眠时间，则返回0。但是他有可能被一个信号提前中断，此时返回剩余秒数。</p>
<p>如果想让程序休眠，直到收到一个信号，则应使用<code>pause</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回：总是-1。</span></span><br></pre></td></tr></table></figure>
<h3 id="加载并运行程序">加载并运行程序</h3>
<p><code>execve</code>可以在当前进程的上下文中，加载并运行一个程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span>;</span><br><span class="line"><span class="comment">// 返回：如果成功则不返回，否则返回-1。</span></span><br></pre></td></tr></table></figure>
<p>filename表示可执行文件的文件名，argv提供程序运行的字符串参数数组，而envp提供环境键值对。</p>
<p>以下函数可以操作环境数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="comment">// 返回：若存在则返回指向name的指针，否则返回NULL。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *newvalue, <span class="type">int</span> overwrite)</span>;</span><br><span class="line"><span class="comment">// 返回：成功为0，失败为-1。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unsetenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="信号">信号※</h2>
<p>一个信号就是一条消息，用来通知进程系统中发生了某些事件。</p>
<ul>
<li>进程尝试除零，则内核会给该进程发一个<strong>SIGFPE</strong>信号。</li>
<li>进程执行一条非法指令，则内核会给进程发一个<strong>SIGILL</strong>信号。</li>
<li>进程进行非法内存引用，则内核会给进程发一个<strong>SIGSEGV</strong>信号。</li>
</ul>
<h3 id="信号术语">信号术语</h3>
<p>传送一个信号到目标进程需要两步。</p>
<ul>
<li><em>发送信号</em>：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送原因可能有：
<ul>
<li>内核检测到一个系统事件，比如除零错或者子进程终止。</li>
<li>一个进程调用了kill函数，将信号发给自身进程或其他进程。</li>
</ul></li>
<li><em>接收信号</em>：目的进程被内核强迫对发来的信号进行反应。进程可以忽略这个信号，终止或者通过用<code>signal</code>函数捕获这个信号，并自定义针对该信号的处理逻辑。目标进程在执行到<span
class="math inline">\(I_{curr}\)</span>被打断之后，内核将控制流交给信号处理函数，可能是系统内置，也可能是用户自定义的函数。执行完成之后，内核将控制流返回目标进程，继续执行<span
class="math inline">\(I_{next}\)</span>。</li>
</ul>
<p><em>待处理信号</em>：一个已发出但未被接收的信号。一个类型的信号至多有一个待处理信号。一个进程可以阻塞某些信号，阻塞后，该种信号仍可以被发送给目标进程，但是不会被接受，直到目标进程取消对该信号的阻塞。</p>
<p>如果进程阻塞了k号信号之后，k号信号被发送给该进程，则内核会设置pending位向量的第k位。</p>
<h3 id="发送信号">发送信号</h3>
<h4 id="进程组">进程组</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 返回：调用进程的进程组ID。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;</span><br><span class="line"><span class="comment">// 返回：成功为0，失败为-1。</span></span><br></pre></td></tr></table></figure>
<p>子进程默认与父进程处于相同PGID。调用<code>setpgid</code>可以改变自己或者其他进程的PGID。</p>
<p>pid为0时，使用当前进程的PID；pgid为0时，使用pid指定的PID作为PGID的数字。</p>
<h4 id="binkill命令">/bin/kill命令</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/kill -9 15213  // 发送9号信号给15213进程。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/bin/kill -9 -15213 // 发送9好信号给15213进程组中的所有进程。</span></span><br></pre></td></tr></table></figure>
<h4 id="从键盘发送信号">从键盘发送信号</h4>
<p>按下Ctrl+C，可以向shell的前台进程组中的每个进程发送一个SIGINT信号。</p>
<p>类似地，按下Ctrl+Z则发送SIGTSTP信号到前台进程组中的每个进程。</p>
<h4 id="kill函数">kill函数</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pid</code>&gt;0：发送<code>sig</code>号信号给<code>pid</code>进程。</li>
<li><code>pid</code>=0：发送给调用进程所在进程组的每一个进程，包括自己。</li>
<li><code>pid</code>&lt;0：发送给进程组<code>|pid|</code>中的每一个进程。</li>
</ul>
<h4 id="alarm函数">alarm函数</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> secs)</span>;</span><br><span class="line"><span class="comment">// 返回：前一次设置闹钟的剩余秒数，若以前没有设置过，则返回0。</span></span><br></pre></td></tr></table></figure>
<p>在<code>secs</code>秒后，向自己发送一个SIGALRM信号。</p>
<p>如果在上一个闹钟尚未触发的时候就又调用了<code>alarm</code>函数，则之前的闹钟被取消，只保留新闹钟，并返回上次闹钟所剩秒数。</p>
<h3 id="接收信号">接收信号</h3>
<p>信号处理的时机：进程从内核态转变为用户态时（系统调用结束或者上下文切换）。</p>
<p>会检查未被阻塞的待处理信号集合。如果有，则选择某一个进行处理。</p>
<p>每个信号都有默认处理行为：</p>
<ul>
<li>进程终止。</li>
<li>进程终止并转储内存。</li>
<li>进程停止知道被SIGCONT重启。</li>
<li>进程忽略改信号。</li>
</ul>
<p>可以通过<code>signal</code>函数修改该进程对某一信号的默认处理行为。（<strong>注意：SIGSTOP和SIGKILL两信号是唯二默认行为不能被修改的信号</strong>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br><span class="line"><span class="comment">// 返回：若成功则返回前次处理函数的指针，若失败则返回SIG_ERR（并不设置errno）。</span></span><br></pre></td></tr></table></figure>
<p><code>handler</code>可以传入三种值：</p>
<ul>
<li><strong>SIG_IGN</strong>：忽略。</li>
<li><strong>SIG_DFL</strong>：恢复默认。</li>
<li><strong>函数指针</strong>：执行改函数流程。</li>
</ul>
<p><strong>注意，信号的处理函数也可以被其他信号打断。</strong></p>
<p><img src="/images/ics2.png" /></p>
<h3 id="阻塞与解阻">阻塞与解阻</h3>
<p>分为两种：</p>
<ul>
<li><em>隐式阻塞</em>：若内核正在执行信号s的处理程序，此时进程又收到了一个信号s，则该信号不会被立即接收，也不会被取消，而是称为待处理信号。</li>
<li><em>显式阻塞</em>：程序调用<code>sigpromask</code>及相关辅助函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigpromask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 返回：均为成功0，失败-1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>;</span><br><span class="line"><span class="comment">// 返回：如果signum是set的成员则返回1，不是则返回0，出错返回-1。</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>how</code>的语义为如何改变当前信号集。有如下三种方式：</p>
<ul>
<li><strong>SIG_BLOCK</strong>：将set中的信号添加到blocked中。</li>
<li><strong>SIG_UNBLOCK</strong>：删除set中的信号。</li>
<li><strong>SIG_SETMASK</strong>：block=set。</li>
</ul>
<h3 id="编写singal-handler信号处理程序">编写singal
handler信号处理程序</h3>
<p>安全信号处理的一些原则。</p>
<ol type="1">
<li><strong>处理函数要尽可能简单</strong>。</li>
<li><strong>调用异步信号安全的函数</strong>。在处理函数中调用其他外部函数时，该外部函数可能会被其他信号中断，导致处理函数被间接中断。应该使用一些保证异步信号安全的函数。他们要么是<em>可重入的</em>，要么不会被其他信号中断。</li>
<li><strong>保存和回复errno</strong>。主程序中可能会用到errno。如果在处理函数中也调用了一些内核函数，则会干扰主程序的判断。应该保证在执行处理函数前后，errno不变。</li>
<li><strong>阻塞所有信号，保护全局数据访问</strong>。</li>
<li><strong>用volatile声明全局变量</strong>。volatile告诉编译器，不要缓存该变量。由于信号处理函数处于内核态，不经过主函数的缓存路线，而直接将变量在内存中修改，用户态函数无法穿透缓存而读取到内存中的最新值。</li>
<li><strong>用sig_atom_t声明标志</strong>。保证读写的原子性。</li>
</ol>
<p><strong>竞争问题（race）</strong></p>
<p>子进程结束会给父进程发送<strong>SIGCHLD</strong>信号，父进程自定义处理函数，捕获之后进行一些处理。但是处理函数和父进程程序中的一些操作可能存在顺序冲突。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigsuspend</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *mask)</span>;</span><br><span class="line"><span class="comment">// 返回：-1。</span></span><br></pre></td></tr></table></figure>
<p>该函数等价于如下流程的原子版本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigpromask(SIG_SETMASK, &amp;mask, &amp;prev);</span><br><span class="line">pause();</span><br><span class="line">sigpromask(SIG_SETMASK, &amp;prev, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>可以使用该函数暂时取消某一信号的阻塞，然后不可中断地进入pause。此时，如果已经有了待处理信号，则pause会被信号唤醒。</p>
<h2 id="非本地跳转未完">非本地跳转（未完）</h2>
<p>将控制直接从一个函数转移至另一个当前正在执行的函数，而不需要通过正常的调用返回。非本地跳转通过<code>setjmp</code>和<code>longjmp</code>函数实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setjmp</span><span class="params">(jmp_buf env)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">(sigjmp_buf env, <span class="type">int</span> savesigs)</span>;</span><br><span class="line"><span class="comment">// 返回：setjmp返回0，sigsetjmp返回非0。</span></span><br></pre></td></tr></table></figure>
<h1 id="第九章-虚拟内存">第九章 虚拟内存※</h1>
<h2 id="物理和虚拟地址">物理和虚拟地址</h2>
<p>主存是一个由M个连续的字节大小的单元组成的数组，每个单元对应了一个地址。</p>
<p>如果我们拿到一个地址值并且直接用该地址取出内存中的值，则称为<strong>物理寻址</strong>。</p>
<p>然而，我们可以<strong>虚拟寻址</strong>。</p>
<p>CPU首先生成一个虚拟地址，但是这个地址并不能直接被用于寻找内存中的数据，需要经过一个
<strong>内存管理单元（MMU）</strong>的翻译，转化为物理地址后，才能取出数据。MMU利用存放在主存中的查询表来进行动态翻译，该表内容由操作系统管理。</p>
<h2 id="地址空间">地址空间</h2>
<p>一个非负整数组成的有序集合<span
class="math inline">\(\{0,1,2,3,\cdots\}\)</span>可以称之为一个地址空间。我们总是假设他是连续的。</p>
<p>CPU从一个有<span
class="math inline">\(N=2^n\)</span>的地址空间中生成虚拟地址。</p>
<p>一个包含<span class="math inline">\(N=2^n\)</span>的地址空间称为<span
class="math inline">\(n\)</span>位地址空间。现代操作系统通常支持32位或者64位虚拟地址空间。</p>
<p>物理地址空间字节数<span
class="math inline">\(M\)</span>不要求一定是2的幂次，但为了方便讨论，假设<span
class="math inline">\(M=2^m\)</span>。</p>
<h2 id="虚拟内存作为缓存的工具">虚拟内存作为缓存的工具</h2>
<p>虚拟内存存储于磁盘上。</p>
<p>主存可以看成是磁盘的缓存，于是二者之间的信息交流有一个固定大小的单位长度。系统将虚拟内存分割为<strong>虚拟页</strong>，每一页的大小是固定的，一般是2的幂次<span
class="math inline">\(P=2^p\)</span>。类似地，物理内存被分割为<strong>物理页</strong>，大小也为<span
class="math inline">\(P\)</span>字节，物理页也被称为页帧。</p>
<p>任何时刻，虚拟页的集合都分为三个不相交的子集：</p>
<ul>
<li><strong>未被分配的</strong>：VM系统尚未分配或创建的页。不占用磁盘空间。</li>
<li><strong>缓存的</strong>：已缓存在物理内存中的已分配页。</li>
<li><strong>未缓存的</strong>：未缓存在物理内存中的已分配页。</li>
</ul>
<h3 id="dram组织结构">DRAM组织结构</h3>
<p>DRAM如果miss了，那么到磁盘中去读取数据的延迟是巨大的。</p>
<p>所以为了尽量避免cache miss，虚拟页往往都很大，通常是4KB~2MB。</p>
<p>虚拟页是fully-associative的，也就是只有一个set，任何虚拟页可以放到任何物理页中。替换算法要比SRAM缓存更复杂精密。</p>
<h3 id="页表">页表</h3>
<p>既然虚拟内存是物理内存的缓存，则需要一个表来记录信息。</p>
<p>页表是存放在物理内存中的数据结构，将虚拟页映射到物理页。</p>
<p><img src="/images/ics3.png" /></p>
<p>在如图所示的例子中，第0，5号虚拟页尚未被分配所以是null；第1，2，4，7号虚拟页已经被缓存到物理内存中，剩下的第3，6号尚未被缓存。</p>
<h3 id="命中">命中</h3>
<p>此时，如果CPU想要访问第2号虚拟地址，那么他就会被翻译成物理内存中的PP1。此时称为页命中。</p>
<h3 id="缺页">缺页</h3>
<p>如果页表没有查询到对应的记录，则出现了一次miss，称为<strong>缺页</strong>。</p>
<p>如果CPU想要访问VP3，则系统触发缺页异常，并调用缺页异常处理程序，它会选择一个物理内存中的牺牲页（PP3对应的VP4）。如果VP4已经被修改，则内核会将他复制回磁盘。然后无论是否修改，都会将页表中关于VP4的信息抹除。然后内核从磁盘复制VP3中的内容到PP3，同时更新页表。然后处理程序返回，重启触发缺页异常的指令，此时他就可以正常访问VP3。</p>
<p>一般情况下，页的写入和擦除都是在发生miss的情况下才进行，这称之为<strong>demand
paging</strong>。也可以按照某种方式，预测可能的miss，在页实际被饮用之前就提前准备好。不过，所有现代机器都不会做这种预测。</p>
<h3 id="分配malloc">分配（malloc）</h3>
<p>将页表中一些尚未分配的条目，在磁盘上分配新的空间。</p>
<h2 id="虚拟内存作为内存管理的工具">虚拟内存作为内存管理的工具</h2>
<p>一些早期系统中，虚拟内存小于物理内存。即便如此，它也可以作为管理内存一个有用的工具。</p>
<p>系统为每个进程提供了独立的页表。</p>
<p><img src="/images/ics4.png" /></p>
<p>在此示例中，两进程的共享了一个物理内存页PP7。在两个进程中访问同一个VP1地址，最终指向的物理地址是不同的。它的作用体现在：</p>
<ol type="1">
<li><strong>简化链接</strong>。允许了每个进程使用完全相同的内存结构。</li>
<li><strong>简化加载</strong>。分配新的虚拟页，用于加载可执行目标文件的各个段，而不需要实际去磁盘中读写物理页。</li>
<li><strong>简化共享</strong>。一般而言，不同进程的虚拟地址空间是私有的，在物理内存中不会被映射到相同的地址。但是，想printf这种大家都会用到的程序，操作系统会将其映射到相同的物理页面。</li>
<li><strong>简化内存分配</strong>。直接在虚拟内存中分配连续的k个页，而不需要在物理内存中寻找。</li>
</ol>
<h2 id="虚拟内存作为内存保护的工具">虚拟内存作为内存保护的工具</h2>
<p>我们需要限制用户态函数对只读代码段的修改，不能允许他访问内核态的代码和数据，也不能让其读写其他进程的私有内存，除非是共享的。</p>
<p>在内核分配一个虚拟页时，可以在页表中的条目里面添加一些控制位，来区分权限。</p>
<p>例如，PTE中有三个许可位：</p>
<ul>
<li><strong>SUP</strong>：表示进程是否必须为内核态。</li>
<li><strong>READ</strong>：读权限。</li>
<li><strong>WRITE</strong>：写权限。</li>
</ul>
<h2 id="地址翻译">地址翻译※</h2>
<p>基本参数和术语。</p>
<table>
<thead>
<tr class="header">
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(N=2^n\)</span></td>
<td>虚拟地址的地址数量</td>
</tr>
<tr class="even">
<td><span class="math inline">\(M=2^m\)</span></td>
<td>物理地址的地址数量</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(P=2^p\)</span></td>
<td>页大小</td>
</tr>
<tr class="even">
<td>VPO</td>
<td>虚拟页偏移量</td>
</tr>
<tr class="odd">
<td>VPN</td>
<td>虚拟页号</td>
</tr>
<tr class="even">
<td>TLBI</td>
<td>TLB index</td>
</tr>
<tr class="odd">
<td>TLBT</td>
<td>TLB tag</td>
</tr>
<tr class="even">
<td>PPO</td>
<td>物理页偏移量</td>
</tr>
<tr class="odd">
<td>PPN</td>
<td>物理页号</td>
</tr>
<tr class="even">
<td>CO</td>
<td>cache offset</td>
</tr>
<tr class="odd">
<td>CI</td>
<td>cache index</td>
</tr>
<tr class="even">
<td>CT</td>
<td>cache tag</td>
</tr>
</tbody>
</table>
<h3 id="基本流程-1">基本流程</h3>
<p><img src="/images/ics5.png" /></p>
<p>上图展示了MMU使用页表来进行翻译的基本流程。</p>
<p>CPU中有一个特殊寄存器称为<strong>页表基址寄存器（PTBR）</strong>，指向当前进程的页表。</p>
<p>n位虚拟地址包含两部分：</p>
<ul>
<li><strong>VPO</strong>：<span
class="math inline">\(p\)</span>位，代表着在一个页中，想要读取的字节的起始位置。</li>
<li><strong>VPN</strong>：<span
class="math inline">\((n-p)\)</span>位，代表虚拟页号。</li>
</ul>
<p>MMU利用VPN来选去适当的PTE。由于虚拟和物理内存的页大小都是<span
class="math inline">\(P\)</span>字节，所以PPO和VPO是相等的。</p>
<h3 id="具体流程">具体流程</h3>
<p><img src="/images/ics6.png" /></p>
<h4 id="hit">hit</h4>
<ol type="1">
<li>CPU生成一个虚拟地址，传给MMU。</li>
<li>MMU生成PTE的地址，并利用各级缓存或主存找到它。</li>
<li>各级缓存或主存返回给MMU一个PTE。</li>
<li>MMU组装物理地址，并传给各级缓存或主存。</li>
<li>各级缓存或主存将数据返回CPU。</li>
</ol>
<p><strong>注意</strong>，PTE的地址（PTEA）和要找的地址是不一样的。页表是常驻于内存的，并通过PTBR寄存器加上条目编号的方式定位。</p>
<h4 id="miss">miss</h4>
<ol type="1">
<li>同上。</li>
<li>同上。</li>
<li>同上。</li>
<li>PTE中的有效位为0，意味着缺页。MMU触发一次异常，将控制传递给缺页异常处理程序。</li>
<li>处理程序确定物理内存中的牺牲页，若该页被修改，则写回磁盘，否则则不需要。</li>
<li>缺页异常换入新页面，并更新PTE。</li>
<li>处理函数将控制交回给原进程，再次执行触发缺页的指令，从头执行，本次执行会hit。</li>
</ol>
<h3 id="高速缓存中的地址">高速缓存中的地址</h3>
<p>大多数系统选择物理地址。PTEA也可以参与缓存。</p>
<h3 id="tlb">TLB</h3>
<p>除了查询目标物理地址，每次翻译的时候，都必须要在各级缓存或者主存中查找PTE的地址，针对PTEA，我们也可以有一个小缓存器，名为<strong>翻译后备缓冲器（TLB）</strong></p>
<p>TLB中存储虚拟地址，每一行都是有一个PTE组成的块。</p>
<p>假设TLB有<span
class="math inline">\(T=2^t\)</span>个set，那么TLBI是由VPN地最低<span
class="math inline">\(t\)</span>位组成的，剩余位组成TLBT。</p>
<p><img src="/images/ics7.png" /></p>
<p><strong>注意</strong>，此处可以使用虚拟地址而不担心不同进程之间混乱的原因是，各个进程的页表物理地址是存在PTBR中的，是不同的。</p>
<h3 id="多级页表">多级页表</h3>
<p>问题：需要的页表条目太多，占用空间太大。由此引出了多级页表的概念。</p>
<p>举例说明，假设虚拟地址为32位，页大小为4KB，一个PTE是4字节。</p>
<p>一级页表映射的是很多连续页表组成的一个大块，或成为<strong>片（chunk）</strong>。此时，一个32位系统只需要1024个一级页表项就够了。</p>
<p>但是只有一级页表，是无法查到某一准确的PTE的。假设一级页表的一个条目已经被分配，则它指向的二级页表是存在的，是连续的1024个PTE。</p>
<p>我们很精确的构造，使得一二级页表都是正好一个页的大小。</p>
<p><img src="/images/ics8.png" /></p>
<p>如图所示，我们对一个虚拟地址进行切分，使用不同的位来到每级页表中去查询，最终得到PPN。然后与VPO组装，形成一个物理地址。</p>
<h2 id="案例">案例</h2>
<h2 id="内存映射">内存映射</h2>
<h2 id="动态内存分配">动态内存分配</h2>
<hr />
<div
style="font-size: 50px; font-weight: bold; color: #777; margin: 22px 0; line-height: normal;">
第三部分 程序间的交互和通信
</div>
<h1 id="第十章-系统级io">第十章 系统级I/O</h1>
<h1 id="第十一章-网络编程">第十一章 网络编程</h1>
<h1 id="第十二章-并发编程">第十二章 并发编程</h1>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>ICS</tag>
        <tag>复习</tag>
        <tag>ipads面试</tag>
      </tags>
  </entry>
</search>
