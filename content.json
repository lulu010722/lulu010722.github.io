{"posts":[{"title":"JPA事务控制与外键死锁","text":"问题背景 在做app作业一的第二部分时，遇到了问题（自以为是问题，没想到老师是故意让我们发现这是个bug）。 1234flowchart LR;A(OrderController::createOrder) --&gt; B(OrderService::createOrder);B --&gt; C(OrderDao::addOne);B --&gt; D(OrderItemDao::addList); 如图，在电子书服务系统E-Book中，我们进行订单创建，一个订单order中包含多个订单项orderItem。 现在我们要对OrderService::createOrder，OrderDao::saveOne和OrderItemDao::saveList进行事务传播控制，分别简称三部分为A，B，C。 若A和B设置为REQUIRED，而C设置为REQUIRES_NEW，则会出现死锁问题。 源代码大致如下。 1234567891011121314151617181920212223242526// OrderServiceImpl.java@Transactionalpublic void createOrder(List&lt;Integer&gt; bookIds, Long userId) { Order order = new Order(); order.setUser(userDao.findOne(userId)); orderDao.addOne(order); // 准备orderItems的List List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;(); ...; orderItemDao.addList(orderItems);}// OrderDaoImpl.java@Transactionalpublic void addOne(Order order) { orderRepository.save(order);}// OrderItemDaoImpl.java@Transactional(propagation = Propagation.REQUIRES_NEW)public void addList(List&lt;OrderItem&gt; orderItems) { orderItemRepository.saveList(orderItems);} 执行结果为死锁。 原因分析 在B执行后，由于与A处在同一事务一里，则事务一拿到了order表中新插入行的锁，不管事务隔离属性如何设置，其他事务均不可进行写操作。而在随后的C流程中，写入orderItems的时候，order_item表中有order的外键，于是他在给order_item新插入的数据上锁之外，也要在order表中对外键所指向的数据加锁。 然而C是拿不到的，因为B已经拿到了。 于是此时，C等待B放锁，但是同时，B又等待C结束返回，从而形成了死锁。 解决方法 该问题说明，并不是所有业务使用REQUIRES_NEW传播都可以，在此场景下，都使用默认的REQUIRED传播属性即可。","link":"jpa%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%A4%96%E9%94%AE%E6%AD%BB%E9%94%81/"},{"title":"CNAME的必要性","text":"首先，如果不写CNAME的话，我们只能从https://username.github.io这个网址进行访问，但是显然如果有一个更好记忆的自定义域名会更好。 于是，我在腾讯云上买了两个域名lulu010722.cn和lulu010722.com。 之后需要在域名提供商处进行域名解析，一般是通过CNAME类型进行解析。 最后，在项目目录中也需要添加CNAME文件，在其中输入使用的域名。 之前一直不懂的地方就是这里，为什么腾讯云的域名已经解析到github page了，还是无法访问，现在推测，可能是权限问题。 在将CNAME文件定义好之后，我们就可以从原本地址和新购买的地址进行访问了。 不过，用原地址访问时，浏览器导航栏会自动切换为自定义地新网址。","link":"cname%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/"},{"title":"cse-lab1踩坑","text":"memcpy与strncpy。 get_inode需要在堆中分配内存。 局部字符数组最好初始化为0。 ino的block不要随便free，有可能free掉别人的合法block。","link":"cse-lab1%E8%B8%A9%E5%9D%91/"},{"title":"cse-lab2a踩坑","text":"ifstream::eof()有bug。 如果有一个文件test.txt，文件内容是： 12341 a2 ab3 abc （注意，最后有一个空行） 则，当时用下面的代码时，会有问题。 12345678910int main() { ifstream in(&quot;test.txt&quot;); while (!in.eof()) { int length; in &gt;&gt; length; char tmp[length + 1]; in.read(tmp, length); cout &lt;&lt; tmp &lt;&lt; endl; }} 原因在于，第三行读取完成后，不管是否将最后的换行符进行了消除，eof()会仍然返回false，因为只有当读到最后一个字符并尝试继续读的时候，该函数才会返回true。","link":"cse-lab2a%E8%B8%A9%E5%9D%91/"},{"title":"计算机系统基础","text":"第一部分 程序结构和执行 第一章 计算机系统漫游 第二章 信息的表示和处理 数据类型的转换 相同位数 以32位int和unsigned举例，基本原则是保持二进制表示不变，而将实际表示的数字调整。 12345int a;unsigned b;a = 0xffffffff; // a = -1b = (int)a; // b = 0xffffffff 不同位数 如果两个类型的长度和符号都不相同，则遵循先扩展/收缩长度，再进行符号转换。 扩展无符号：补零 扩展有符号：补最高位 截断无符号：直接截断 截断有符号：直接截断 IEEE浮点数表示 \\(V=(-1)^s\\times M\\times 2^E\\) \\(s\\): 符号位； \\(M\\): 尾数； \\(E\\): 阶码。 在计算机中，我们也按照这三个部分来表示。 一个单独符号位\\(s\\)。 \\(k\\)位阶码字段\\(e=e_{k-1}\\cdots e_1e_0\\)编码阶码\\(E\\)。 \\(n\\)位小数字段\\(f=f_{n-1}\\cdots f_1f_0\\)编码尾数\\(M\\)，但是编码对应的值与\\(E\\)是否等于零有关（格式化与非格式化表示）。 共有三种情况 格式化，\\(e\\)的各位不为全0页不为全1。\\(E=e-Bias\\), \\(e\\)无符号数，Bias=\\(2^{k-1}-1\\)，\\(M=1+f\\)。 非格式化，此时\\(e\\)各位全为0。\\(E=1-Bias\\)，\\(M=f\\)。 特殊值，此时\\(e\\)各位全为1。如果\\(f\\)的各位全为0，则表示无穷大，否则表示NaN。 浮点之间，浮点与整形的转换 int-&gt;float，不会溢出，但是可能会损失精度； int或float-&gt;double，不会溢出也不会损失精度； double-&gt;float，有可能会溢出为\\(+\\infty\\)或者\\(-\\infty\\)，若不溢出，也可能损失精度； float或double-&gt;int，向零取整，值可能会溢出，但是并未规定处理方式。 第三章 程序的机器级表示 第四章 处理器体系结构 第五章 优化程序性能 第六章 储存器层次结构 第二部分 在系统上运行程序 第七章 链接 基本流程 12flowchart TB;A(main.c源代码) --&gt; cpp预处理器 --&gt; B(main.i中间文件) --&gt; cc1编译器 --&gt; C(main.s汇编文件) --&gt; as汇编器 --&gt; D(main.o可重定位目标文件) --&gt; ld链接器 --&gt; E(main可执行目标文件) --&gt; loader加载器 --&gt; F(运行) 静态链接 可重定向目标文件格式 部分 含义 ELF头 文件的元信息，包括ELF头本身大小，目标文件类型（可重定向，可执行，共享），机器类型，节头部表的偏移，节头部表中的条目大小和数量。 .text 以编译程序的机器代码。 .rodata 只读数据，例如printf语句中的格式化字符串和switch语句的跳转表。 .data 已初始化的全局和静态C变量。局部C变量保存于栈中，既不存在于.data，也不存在于.bss。 .bss 未初始化的静态C变量，以及所有被初始化为0的全局和静态C变量。区分是否初始化为0是为了节省空间。未初始化的全局变量将被放在COMMON伪节。 .symtab 符号表，存放程序中定义和引用的函数和全局变量的信息。和编译器的符号表不同，.symtab不包含局部变量。 .rel.text .text节中位置的列表，当链接器将目标文件和其他文件组合时，需要修改这些位置。可执行目标文件不需要重定位信息，所以一般没有该条目。 .rel.data 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已经初始化的全局变量，如果他的初始值是一个全局变量的地址或者外部定义函数的地址，都需要被修改。 .debug 调试符号表，条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及C源文件。只有以-g选项调用编译器时，才会得到这张表。 .line C源程序中行号和.text节中机器指令之间的映射，只有以-g选项调用编译器时，才会得到这张表。 .strtab 一个字符串表，内容包括.symtab和.debug中的符号表，以及节头部中的节名字。是以null结尾的字符串序列。 节头部表 描述目标文件。 符号和符号表 可重定向目标文件m的.symtab中有三种不同的符号： 由模块m定义并能被其他模块访问的全局符号，全局链接器符号对应于非静态C函数和全局变量。 由其他模块定义并被m模块引用的的全局符号，称为外部符号，对应于在其他文件中定义的非静态C函数和全局变量。 只被模块m定义和引用的局部符号，对应于静态C函数和静态全局变量。 动态局部变量和全局静态变量有区别，前者由栈管理，链接器只考虑后者。 但是，局部变量也可以被声明为静态。此时它是不被栈管理的。相反，编译器会在.data或者.bss中为每个定义分配空间，并在符号表中创建有唯一名称的链接器符号。 符号表是由一种结构体构成的数组，结构体定义如下： 123456789typedef struct { int name; // 在字符串表中的字节偏移，指向以null结尾的字符串名字。 char type:4, // 区分数据和函数。 binding:4; // 区分本地和全局。 char reserved; short section; // 符号所在节。 long value; // 符号的地址。在可重定向目标文件中，是距定义目标的节起始位置的偏移，而对于可执行目标文件来说，是一个绝对运行时地址。 long size; // 目标的大小，单位为字节。} Elf64_Symbol; 符号表中的一个条目，还可以表示一个节，也可以用来表示原始文件路径名。 伪节 除了表中列出的节之外，还有三个伪节，在节头部表中没有条目。伪节仅存在于可重定向目标文件。 ABS：表示不该被重定向的符号； UNDEF：表示未定义的符号，也就是在本目标模块中引用，但是在其他地方定义的符号； COMMON：表示还未被分配位置的未初始化的数据目标。此时，value字段给出对齐要求，size指的是最小的大小。 COMMON和.bss的区别。 COMMON存放未初始化的全局变量（也就是弱符号）； .bss存放未初始化的静态变量，以及初始化为0的全局和静态变量。 造成这一区分的主要原因是，编译器允许不同模块中有同名的符号。 符号解析 强符号：函数和已经初始化的全局变量； 弱符号：未初始化的全局变量。 三条规则 不允许有同名的强符号； 如果有强符号和弱符号同名，则选择强符号； 如果若干弱符号同名，则随意选择一个。 静态库 多个标准可重定向目标文件，可以打包形成一个归档文件，以.a后缀名结尾，又称为静态库。 在使用gcc命令进行编译的时候，需要将用到的静态库显式地添加到命令行。 例如gcc main.c /usr/lib/libm.a /usr/lib/libc.a，而libc.a是被默认链接地，所以并不需要指出。 静态库的连接顺序是有所谓的。未定义的符号所在模块，必须出现在定义模块之前。 重定位 链接器知道了.text和.data的确切大小，可以进行地址的重定位。 重定位节和符号定义。将所有模块的同种节合成一个，例如将所有模块的.data节合成一个大的.data节，输出到可执行目标文件的.data节。然后链接器为每个聚合节，聚合节中的每一个原始节，和节中出现的符号分配运行时内存地址。 重定位节中的符号引用。修改代码和数据节中对每个符号的引用。这依赖于.rel.text和.rel.data两个重定位节。 代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。 条目格式如下。 123456typedef struct { long offset; // 要被修改的引用相对于节的偏移。 long type:32, // 重定位类型，告诉链接器如何修改。 symbol:32; // 该引用指向的符号。 long addend; // 一些类型的重定位需要使用该信息来修改偏移量。} Elf64_Rela; ELF定义了32种不同的重定位模式。 R_X86_64_PC32：32位PC相对地址； R_X86_64_32：32位绝对地址。 这两种类型支持x86-64小型代码模型，即假设代码和数据总体大小小于2GB。 可执行目标文件 部分 段属性 内容 ELF头 只读内存段（代码段） 段头部表 只读内存段 将连续的文件节映射到运行时的内存段 .init 只读内存段 .text 只读内存段 .rodata 只读内存段 .data 读写内存段（数据段） .bss 读写内存段 .symtab 不加载到内存 .debug 不加载到内存 .line 不加载到内存 .strtab 不加载到内存 节头部表 不加载到内存 描述目标文件的节 程序头部表 描述了将代码段加载到内存的映射关系。 1234567只读段LOAD off 0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**21 filesz 0x000000000000069c memsz 0x000000000000069c flags r-x读写段LOAD off 0x0000000000000df8 vaddr 0x0000000000600df8 paddr 0x0000000000600df8 align 2**21 filesz 0x0000000000000228 memsz 0x0000000000000230 flags rw- filesz和memsz不一致的原因在于，.bss在目标文件中是不需要占用空间的，但是在内存中需要为其留出位置并初始化为0。 off和vaddr要求对齐，即\\(\\text{vaddr}\\pmod {\\text{align}}=\\text{off}\\pmod {\\text{align}}\\)。这种要求的原因，与虚拟内存的组织方式有关。 加载可执行目标文件 在命令行中执行内置命令或用./prog来执行一个可执行文件，或者调用`execve函数，都可以调用加载器（loader）。 动态链接 静态库的一个问题是，所有进程都会加载相同的标准静态库函数，造成内存的极大浪费。 共享库在运行或加载时，加载到任意的内存位置，并和一个在内存中的程序链接起来。 共享库也叫共享目标，在Linux中以.so文件后缀结尾，在Windows中则是DLL（动态链接库）。 两种不同的共享方式： 一个库只对应一个.so文件，所有引用该库的文件共享.text和.data中的数据，而不用嵌入到引用模块的可执行目标文件中； 在内存中，共享库的.text节的一个副本可以被不同的正在运行的进程共享。 12345flowchart TB;A(main.c) &amp; B(vector.h) --&gt; a[&quot;翻译器(cpp, cc1, as)&quot;] --&gt; C(可重定位目标文件main.o)C &amp; D(libc.so\\nlibvector.so) --&gt; b[&quot;链接器(ld)&quot;] --&gt; E(&quot;部分链接地可执行目标文件prog1&quot;) --&gt; c[&quot;加载器(execve)&quot;]c &amp; F(&quot;libc.so\\nlibvector.so&quot;) --&gt; d[&quot;动态链接器(ld-linux.so)&quot;] --&gt; G(&quot;完全链接的可执行目标文件prog2&quot;) 位置无关代码（PIC） 如何在多个进程中共享一个程序副本？ 如果为每一个共享库都分配一个固定的地址空间，那么弊端很多，主要是难于管理，并且也有很大浪费。 可加载而无需重定向的代码称之为位置无关代码（Position-Independent Code）。 全局偏移量表（GOT） 首先，编译器在.data开始的地方创建一个全局偏移量表（Global Offset Table）。每个被该模块引用的全局数据目标（过程或者全局变量）都有一个8字节的条目。同时编译器还为GOT中的每一个条目生成一个重定向记录，由于代码段和数据段的间隔是不变的，编译器可以使用PC相对寻址来重定位。 过程链接表（PLT） 为了避免动态链接在加载时，对成百上千个不需要的符号进行重定位，GNU提出了延迟绑定。延迟绑定需要使用GOT和过程连接表（Procedure Linkage Table）两个数据结构。如果一个目标模块调用了共享库中定义的任何函数，那么他就有GOT和PLT。GOT是数据段的一部分，PLT是代码段的一部分。 库打桩机制 第八章 异常控制流 异常 异常的发生可能与当前执行的指令有关，例如当前指令发生了一些缺页错误，或者尝试除零；也可能与当前指令没有关系，例如定时器到时，或者IO操作完成。 当程序检测到有异常时，会通过异常表来进行间接的函数调用，到一个专门处理这些事件的操作系统子程序（异常处理程序）。处理完成后，根据异常事件的类型，会发生三种情况。 将控制返回\\(I_{curr}\\)，重新执行； 将控制返回\\(I_{next}\\)，跳过之前的指令； 终止被中断的程序。 异常处理 系统为每种异常都分配了一个异常号码，有一些来自于处理器的设计者，有一些来自于操作系统内核。 系统在启动时，操作系统会分配并初始化一张异常表，每个条目都指向对应异常的处理函数的地址。 异常表的起始地址存放在名为异常表基址寄存器的特殊寄存器中。 异常处理函数的调用与普通函数调用有一些区别： 将当前函数的返回地址压栈的时候，根据异常类型，要确定是压入当前指令地址，还是下一个指令的地址； 处理函数会把一些额外的处理器状态压栈，但是栈有内核栈和用户栈的区别。处理函数由于处于内核态，则压入内核栈，同时它也对所有系统资源具有完全访问权限。 异常种类 中断（interrupt） 陷阱（trap） 故障（fault） 终止（abort） 类别 原因 异步/同步 返回行为 中断 来自IO设备的信号 异步（与当前指令无关的异常） 总是返回下一条指令 陷阱 有意的异常 同步（当前指令的直接产物） 总是返回下一条指令 故障 可能恢复的异常 同步（当前指令的直接产物） 可能返回当前地址 终止 不可恢复的异常 同步（当前指令的直接产物） 不会返回 中断 IO设备会异步地向CPU的一个引脚发送信号。 CPU会在处理完当前指令之后调用异常处理器，而不是直接打断执行到中间状态的当前指令，于是原来的进程就像没有受到中断一样，继续执行下一条指令。 陷阱和系统调用 是有意为之的异常，主要是用来进行系统调用，例如调用系统层的read，write，fork等等函数。 处理器提供了一个特殊的syscall n指令，n代表系统函数的编号。 故障 用户程序发生了一个错误情况，触发故障处理函数。如果处理函数能够修复故障，则会返回出现故障的用户指令重新执行，否则，处理函数将会直接在内核态发送一个新的终止异常，结束用户程序。 终止 终止是不可修复的致命错误，通常是一些硬件错误。 Linux/x86-64系统异常 有256种异常，0-31号由Intel的设计师们定义，因此对于任何x86-64的机器，这些异常都是一样的，32-255号是由操作系统定义的中断和陷阱。 Linux故障和终止举例 除法错误：编号0，不会恢复，Linux shell通常会报“浮点异常（Floating exception）”的异常信息。 一般保护故障：编号13，有许多原因，但通常是由于程序引用了一个未定义的虚拟内存区域，例如访问空指针，或尝试修改一个只读片段。不会恢复，Linux shell通常报告为“段故障（Segmentation fault）”。 缺页：编号14，与虚拟内存的管理有关。 机器检查：编号18，硬件错误。 Linux系统调用 Linux提供了上百个系统调用，每个都对应于一个整数号，对应于内核中的一个跳转表（注意该跳转表与异常表并不相同）。 调用syscall指令即可进入内核态执行系统函数。在开始前，需要将编号存入%rax寄存器，并将可能用到的参数依次存入%rdi、%rsi、%rdx、%rcx、%r8、%r9这六个寄存器中。系统函数无法使用栈传递更多的参数，于是一个系统函数最多只有六个参数。 进程※ 提供一种假象，让我们的程序独占所有计算机资源。 进程提供了两个关键抽象： 一个独立的逻辑控制流； 一个私有的地址空间。 私有地址空间 一般而言，一个进程所在的内存字节是不能被其他进程进行读写的，也就是所谓私有。 每个进程的地址空间都有相同的结构。 用户态和内核态 处理器必须限制一个应用可以执行的指令和可以访问的地址空间范围。通常用一个模式位来提供这种功能。当设置了该模式位时，系统处于内核态，可以访问内存中的任何位置。 在用户态中，如果直接执行特权指令，例如停止处理器，改变模式位，发起IO操作，或者访问内核态的代码和数据，都会直接导致保护故障。用户必须通过系统调用接口来间接的调用内核数据和代码。 用户态进入内核态的唯一方法是触发异常。 Linux提供了一种/proc文件系统，他允许用户访问内核数据结构的内容，例如CPU类型，某个进程所使用的内存段。 上下文切换 以进程A进行read系统调用为例。 进程A通过系统调用触发陷阱异常，进入内核态； 内核在执行了一部分陷阱处理逻辑之后，将需要等待磁盘的返回，此时它将进行上下文切换，切换到进程B的内核态； 系统进入进程B的用户态并执行代码； 进程B在执行过程中，受到了来自磁盘的中断，表示数据已经读取成功； 进程B进入内核态，随后内核将上下文切换回A进程； 系统进入进程A的用户态，继续执行剩余的用户代码。 系统调用的错误 和用户函数一样，系统调用也可能出现错误。此时通常会返回-1，并设置全局整数变量errno来表示出了什么问题。 通过strerror(errno)函数，我们可以将errno对应的错误信息打印出来。 进程控制※ 接下来将复习Unix的进程控制函数，数量较多。 进程ID 每个进程都有一个正数进程ID。可以通过getpid获取，getppid则返回父进程的pid。 12pid_t getpid(void);pid_t getppid(void); 创建和终止进程 进程的状态有三种： 运行：或者正在执行，或者在等待内核再一次切换上下文回来继续执行； 停止：被挂起，且不会被调度。当收到SIGSTOP，SIGTSTP，SIGTTIN或者SIGTTOU等信号时，进程就会停止。当他收到SIGCONT信号时，程序再次回到运行状态； 终止：程序永远的停止了，原因可能有三个： 收到默认行为为终止进程的信号； 从主程序返回； 调用了exit函数。 12void exit(int status);// 不返回。 父进程可通过fork函数创建一个新的进程。 12pid_t fork(void);// 返回：子进程为0，父进程为子进程PID；出错则返回-1。 调用一次，返回两次，分别在父进程和子进程中。在父进程中，返回的是子进程的PID，在子进程中，返回0。通过这一特性，我们就可以区分当前进程是父进程还是子进程。 并发执行。进程一旦创建完毕，父子进程的执行是并发的，他们可能以任何可能的顺序交替执行。 相同但是独立的地址空间。fork函数执行完之后，两进程的地址空间及其内容是一样的，但是针对其进行的修改是完全独立的。 共享文件。子进程会继承父进程打开的所有文件。 进程回收 进程的三种状态之一是终止。但是终止并不意味着系统会将该进程所占用的资源立刻回收，清空，并释放。父进程需要主动地去回收它。一个终止但并未被回收的进程称之为僵尸进程。当父进程回收子进程时，内核可以将子进程的退出状态传递给父进程。 系统中的所有进程，都是init进程的子进程。init的PID是1，是所有进程的祖先，在系统启动时被内核创建，永远不会退出。 在一个进程退出时，如果他存在孤儿进程，则init会主动去收养该进程作为自己的子进程。如果一个父进程在退出时并未回收其僵尸子进程，则init会自动回收他们。但是，对于长时间不退出的进程，例如shell或者服务器，我们需要手动去回收其子进程。 12pid_t waitpid(pid_t pid, int *statusp, int options);// 返回：如果成功，则为子进程PID；如果options设置了WNOHANG则为0；其他为-1。 该函数的行为比较复杂。 默认情况下（options=0），进程被挂起，直到其等待集合中的某一个子进程终止。 修改等待集合，通过指定pid参数来控制。 pid&gt;0：等待PID=pid的进程返回。 pid=-1：等待集合为父进程的所有子进程。 修改默认行为，通过修改options来控制。 WNOHANG：如果调用的时候，等待集合里面没有已经终止的子进程，则立即返回。 WUNTRACED：除了等待终止，也等待停止。 WCONTINUED：除了等待终止，也等待一个等待集合中被停止的进程被SIGCONT重新激活。 可以将他们用或运算组合起来。 检查已回收子进程的退出状态 设int status = *statusp;（如果statusp非空）。 waitpid会修改改指针指向的值，然后父进程可以用一些预定义的宏来获取信息。 WIFEXITED：如果子进程正常终止，则返回真。 WEXITSTATUS：返回退出状态。 WIFSIGNALED：如果子进程是因为一个未被捕获的信号终止的，则返回真。 WTERMSIG：返回引起终止的信号编号。 WIFSTOPPED：如果因为子进程停止而返回，则返回真。 WSTOPSIG：返回引起子进程停止的信号编号。 WIFCONTINUED：如果因为子进程重新运行而返回，则返回真。 错误返回 如果没有子进程，则返回-1，并设置errno为ECHILD；如果waitpid被一个信号中断，则返回-1，并设置error为EINTR。 进程休眠 可以用sleep来让进程休眠指定时间。 12unsigned int sleep(unsigned int secs);// 返回：还要休眠的秒数。 sleep如果达成了设置的休眠时间，则返回0。但是他有可能被一个信号提前中断，此时返回剩余秒数。 如果想让程序休眠，直到收到一个信号，则应使用pause。 12int pause(void);// 返回：总是-1。 加载并运行程序 execve可以在当前进程的上下文中，加载并运行一个程序。 12int execve(const char *filename, const char *argv[], const char *envp[]);// 返回：如果成功则不返回，否则返回-1。 filename表示可执行文件的文件名，argv提供程序运行的字符串参数数组，而envp提供环境键值对。 以下函数可以操作环境数组。 12345char *getenv(const char *name);// 返回：若存在则返回指向name的指针，否则返回NULL。int setenv(const char *name, const char *newvalue, int overwrite);// 返回：成功为0，失败为-1。void unsetenv(const char *name); 信号※ 一个信号就是一条消息，用来通知进程系统中发生了某些事件。 进程尝试除零，则内核会给该进程发一个SIGFPE信号。 进程执行一条非法指令，则内核会给进程发一个SIGILL信号。 进程进行非法内存引用，则内核会给进程发一个SIGSEGV信号。 信号术语 传送一个信号到目标进程需要两步。 发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。发送原因可能有： 内核检测到一个系统事件，比如除零错或者子进程终止。 一个进程调用了kill函数，将信号发给自身进程或其他进程。 接收信号：目的进程被内核强迫对发来的信号进行反应。进程可以忽略这个信号，终止或者通过用signal函数捕获这个信号，并自定义针对该信号的处理逻辑。目标进程在执行到\\(I_{curr}\\)被打断之后，内核将控制流交给信号处理函数，可能是系统内置，也可能是用户自定义的函数。执行完成之后，内核将控制流返回目标进程，继续执行\\(I_{next}\\)。 待处理信号：一个已发出但未被接收的信号。一个类型的信号至多有一个待处理信号。一个进程可以阻塞某些信号，阻塞后，该种信号仍可以被发送给目标进程，但是不会被接受，直到目标进程取消对该信号的阻塞。 如果进程阻塞了k号信号之后，k号信号被发送给该进程，则内核会设置pending位向量的第k位。 发送信号 进程组 1234pid_t getpgrp(void);// 返回：调用进程的进程组ID。int setpgid(pid_t pid, pid_t pgid);// 返回：成功为0，失败为-1。 子进程默认与父进程处于相同PGID。调用setpgid可以改变自己或者其他进程的PGID。 pid为0时，使用当前进程的PID；pgid为0时，使用pid指定的PID作为PGID的数字。 /bin/kill命令 12$ /bin/kill -9 15213 // 发送9号信号给15213进程。$ /bin/kill -9 -15213 // 发送9好信号给15213进程组中的所有进程。 从键盘发送信号 按下Ctrl+C，可以向shell的前台进程组中的每个进程发送一个SIGINT信号。 类似地，按下Ctrl+Z则发送SIGTSTP信号到前台进程组中的每个进程。 kill函数 1int kill(pid_t pid, int sig); pid&gt;0：发送sig号信号给pid进程。 pid=0：发送给调用进程所在进程组的每一个进程，包括自己。 pid&lt;0：发送给进程组|pid|中的每一个进程。 alarm函数 12unsigned int alarm(unsigned int secs);// 返回：前一次设置闹钟的剩余秒数，若以前没有设置过，则返回0。 在secs秒后，向自己发送一个SIGALRM信号。 如果在上一个闹钟尚未触发的时候就又调用了alarm函数，则之前的闹钟被取消，只保留新闹钟，并返回上次闹钟所剩秒数。 接收信号 信号处理的时机：进程从内核态转变为用户态时（系统调用结束或者上下文切换）。 会检查未被阻塞的待处理信号集合。如果有，则选择某一个进行处理。 每个信号都有默认处理行为： 进程终止。 进程终止并转储内存。 进程停止知道被SIGCONT重启。 进程忽略改信号。 可以通过signal函数修改该进程对某一信号的默认处理行为。（注意：SIGSTOP和SIGKILL两信号是唯二默认行为不能被修改的信号） 12sighandler_t signal(int signum, sighandler_t handler);// 返回：若成功则返回前次处理函数的指针，若失败则返回SIG_ERR（并不设置errno）。 handler可以传入三种值： SIG_IGN：忽略。 SIG_DFL：恢复默认。 函数指针：执行改函数流程。 注意，信号的处理函数也可以被其他信号打断。 阻塞与解阻 分为两种： 隐式阻塞：若内核正在执行信号s的处理程序，此时进程又收到了一个信号s，则该信号不会被立即接收，也不会被取消，而是称为待处理信号。 显式阻塞：程序调用sigpromask及相关辅助函数。 12345678int sigpromask(int how, const sigset_t *set, sigset_t *oldset);int sigemptyset(sigset_t *set);int sigfillset(sigset_t *set);int sigaddset(sigset_t *set, int signum);int sigdelset(sigset_t *set, int signum);// 返回：均为成功0，失败-1。int sigismember(const sigset_t *set, int signum);// 返回：如果signum是set的成员则返回1，不是则返回0，出错返回-1。 其中，how的语义为如何改变当前信号集。有如下三种方式： SIG_BLOCK：将set中的信号添加到blocked中。 SIG_UNBLOCK：删除set中的信号。 SIG_SETMASK：block=set。 编写singal handler信号处理程序 安全信号处理的一些原则。 处理函数要尽可能简单。 调用异步信号安全的函数。在处理函数中调用其他外部函数时，该外部函数可能会被其他信号中断，导致处理函数被间接中断。应该使用一些保证异步信号安全的函数。他们要么是可重入的，要么不会被其他信号中断。 保存和回复errno。主程序中可能会用到errno。如果在处理函数中也调用了一些内核函数，则会干扰主程序的判断。应该保证在执行处理函数前后，errno不变。 阻塞所有信号，保护全局数据访问。 用volatile声明全局变量。volatile告诉编译器，不要缓存该变量。由于信号处理函数处于内核态，不经过主函数的缓存路线，而直接将变量在内存中修改，用户态函数无法穿透缓存而读取到内存中的最新值。 用sig_atom_t声明标志。保证读写的原子性。 竞争问题（race） 子进程结束会给父进程发送SIGCHLD信号，父进程自定义处理函数，捕获之后进行一些处理。但是处理函数和父进程程序中的一些操作可能存在顺序冲突。 12int sigsuspend(const sigset_t *mask);// 返回：-1。 该函数等价于如下流程的原子版本： 123sigpromask(SIG_SETMASK, &amp;mask, &amp;prev);pause();sigpromask(SIG_SETMASK, &amp;prev, NULL); 可以使用该函数暂时取消某一信号的阻塞，然后不可中断地进入pause。此时，如果已经有了待处理信号，则pause会被信号唤醒。 非本地跳转（未完） 将控制直接从一个函数转移至另一个当前正在执行的函数，而不需要通过正常的调用返回。非本地跳转通过setjmp和longjmp函数实现。 123int setjmp(jmp_buf env);int sigsetjmp(sigjmp_buf env, int savesigs);// 返回：setjmp返回0，sigsetjmp返回非0。 第九章 虚拟内存※ 物理和虚拟地址 主存是一个由M个连续的字节大小的单元组成的数组，每个单元对应了一个地址。 如果我们拿到一个地址值并且直接用该地址取出内存中的值，则称为物理寻址。 然而，我们可以虚拟寻址。 CPU首先生成一个虚拟地址，但是这个地址并不能直接被用于寻找内存中的数据，需要经过一个 内存管理单元（MMU）的翻译，转化为物理地址后，才能取出数据。MMU利用存放在主存中的查询表来进行动态翻译，该表内容由操作系统管理。 地址空间 一个非负整数组成的有序集合\\(\\{0,1,2,3,\\cdots\\}\\)可以称之为一个地址空间。我们总是假设他是连续的。 CPU从一个有\\(N=2^n\\)的地址空间中生成虚拟地址。 一个包含\\(N=2^n\\)的地址空间称为\\(n\\)位地址空间。现代操作系统通常支持32位或者64位虚拟地址空间。 物理地址空间字节数\\(M\\)不要求一定是2的幂次，但为了方便讨论，假设\\(M=2^m\\)。 虚拟内存作为缓存的工具 虚拟内存存储于磁盘上。 主存可以看成是磁盘的缓存，于是二者之间的信息交流有一个固定大小的单位长度。系统将虚拟内存分割为虚拟页，每一页的大小是固定的，一般是2的幂次\\(P=2^p\\)。类似地，物理内存被分割为物理页，大小也为\\(P\\)字节，物理页也被称为页帧。 任何时刻，虚拟页的集合都分为三个不相交的子集： 未被分配的：VM系统尚未分配或创建的页。不占用磁盘空间。 缓存的：已缓存在物理内存中的已分配页。 未缓存的：未缓存在物理内存中的已分配页。 DRAM组织结构 DRAM如果miss了，那么到磁盘中去读取数据的延迟是巨大的。 所以为了尽量避免cache miss，虚拟页往往都很大，通常是4KB~2MB。 虚拟页是fully-associative的，也就是只有一个set，任何虚拟页可以放到任何物理页中。替换算法要比SRAM缓存更复杂精密。 页表 既然虚拟内存是物理内存的缓存，则需要一个表来记录信息。 页表是存放在物理内存中的数据结构，将虚拟页映射到物理页。 在如图所示的例子中，第0，5号虚拟页尚未被分配所以是null；第1，2，4，7号虚拟页已经被缓存到物理内存中，剩下的第3，6号尚未被缓存。 命中 此时，如果CPU想要访问第2号虚拟地址，那么他就会被翻译成物理内存中的PP1。此时称为页命中。 缺页 如果页表没有查询到对应的记录，则出现了一次miss，称为缺页。 如果CPU想要访问VP3，则系统触发缺页异常，并调用缺页异常处理程序，它会选择一个物理内存中的牺牲页（PP3对应的VP4）。如果VP4已经被修改，则内核会将他复制回磁盘。然后无论是否修改，都会将页表中关于VP4的信息抹除。然后内核从磁盘复制VP3中的内容到PP3，同时更新页表。然后处理程序返回，重启触发缺页异常的指令，此时他就可以正常访问VP3。 一般情况下，页的写入和擦除都是在发生miss的情况下才进行，这称之为demand paging。也可以按照某种方式，预测可能的miss，在页实际被饮用之前就提前准备好。不过，所有现代机器都不会做这种预测。 分配（malloc） 将页表中一些尚未分配的条目，在磁盘上分配新的空间。 虚拟内存作为内存管理的工具 一些早期系统中，虚拟内存小于物理内存。即便如此，它也可以作为管理内存一个有用的工具。 系统为每个进程提供了独立的页表。 在此示例中，两进程的共享了一个物理内存页PP7。在两个进程中访问同一个VP1地址，最终指向的物理地址是不同的。它的作用体现在： 简化链接。允许了每个进程使用完全相同的内存结构。 简化加载。分配新的虚拟页，用于加载可执行目标文件的各个段，而不需要实际去磁盘中读写物理页。 简化共享。一般而言，不同进程的虚拟地址空间是私有的，在物理内存中不会被映射到相同的地址。但是，想printf这种大家都会用到的程序，操作系统会将其映射到相同的物理页面。 简化内存分配。直接在虚拟内存中分配连续的k个页，而不需要在物理内存中寻找。 虚拟内存作为内存保护的工具 我们需要限制用户态函数对只读代码段的修改，不能允许他访问内核态的代码和数据，也不能让其读写其他进程的私有内存，除非是共享的。 在内核分配一个虚拟页时，可以在页表中的条目里面添加一些控制位，来区分权限。 例如，PTE中有三个许可位： SUP：表示进程是否必须为内核态。 READ：读权限。 WRITE：写权限。 地址翻译※ 基本参数和术语。 符号 描述 \\(N=2^n\\) 虚拟地址的地址数量 \\(M=2^m\\) 物理地址的地址数量 \\(P=2^p\\) 页大小 VPO 虚拟页偏移量 VPN 虚拟页号 TLBI TLB index TLBT TLB tag PPO 物理页偏移量 PPN 物理页号 CO cache offset CI cache index CT cache tag 基本流程 上图展示了MMU使用页表来进行翻译的基本流程。 CPU中有一个特殊寄存器称为页表基址寄存器（PTBR），指向当前进程的页表。 n位虚拟地址包含两部分： VPO：\\(p\\)位，代表着在一个页中，想要读取的字节的起始位置。 VPN：\\((n-p)\\)位，代表虚拟页号。 MMU利用VPN来选去适当的PTE。由于虚拟和物理内存的页大小都是\\(P\\)字节，所以PPO和VPO是相等的。 具体流程 hit CPU生成一个虚拟地址，传给MMU。 MMU生成PTE的地址，并利用各级缓存或主存找到它。 各级缓存或主存返回给MMU一个PTE。 MMU组装物理地址，并传给各级缓存或主存。 各级缓存或主存将数据返回CPU。 注意，PTE的地址（PTEA）和要找的地址是不一样的。页表是常驻于内存的，并通过PTBR寄存器加上条目编号的方式定位。 miss 同上。 同上。 同上。 PTE中的有效位为0，意味着缺页。MMU触发一次异常，将控制传递给缺页异常处理程序。 处理程序确定物理内存中的牺牲页，若该页被修改，则写回磁盘，否则则不需要。 缺页异常换入新页面，并更新PTE。 处理函数将控制交回给原进程，再次执行触发缺页的指令，从头执行，本次执行会hit。 高速缓存中的地址 大多数系统选择物理地址。PTEA也可以参与缓存。 TLB 除了查询目标物理地址，每次翻译的时候，都必须要在各级缓存或者主存中查找PTE的地址，针对PTEA，我们也可以有一个小缓存器，名为翻译后备缓冲器（TLB） TLB中存储虚拟地址，每一行都是有一个PTE组成的块。 假设TLB有\\(T=2^t\\)个set，那么TLBI是由VPN地最低\\(t\\)位组成的，剩余位组成TLBT。 注意，此处可以使用虚拟地址而不担心不同进程之间混乱的原因是，各个进程的页表物理地址是存在PTBR中的，是不同的。 多级页表 问题：需要的页表条目太多，占用空间太大。由此引出了多级页表的概念。 举例说明，假设虚拟地址为32位，页大小为4KB，一个PTE是4字节。 一级页表映射的是很多连续页表组成的一个大块，或成为片（chunk）。此时，一个32位系统只需要1024个一级页表项就够了。 但是只有一级页表，是无法查到某一准确的PTE的。假设一级页表的一个条目已经被分配，则它指向的二级页表是存在的，是连续的1024个PTE。 我们很精确的构造，使得一二级页表都是正好一个页的大小。 如图所示，我们对一个虚拟地址进行切分，使用不同的位来到每级页表中去查询，最终得到PPN。然后与VPO组装，形成一个物理地址。 案例 内存映射 动态内存分配 第三部分 程序间的交互和通信 第十章 系统级I/O 第十一章 网络编程 第十二章 并发编程","link":"%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"},{"title":"git——人类好朋友","text":"本地/远程分支创建和删除 123456# 删除本地分支git branch -d &lt;branch-name&gt;# 删除远程分支git push -d &lt;remote-name&gt; &lt;branch-name&gt;# 删除已经不存在于远程仓库的本地远程分支git remote prune &lt;remote-name&gt; git submodule初步运用 实际场景：在博客主仓库中日常更新日志内容的同时，想要对主题仓库进行个性化修改，或者更进一步，对原主题仓库提出PR，进行contribute。主仓库需要拥有子仓库的文件内容，因为前者要根据后者的资源进行页面的渲染。 这样，我们就需要在主仓库（blog）中包含子仓库（themes）。为了更方便地管理他们，需要使用git submodule。 原来的做法 将themes.git文件夹删除，使其失去版本控制，并将themes（.gitignore的除外）加入主仓库的版本控制。在本地的修改可以直接更新到主仓库，在github直接执行npm run build的CI任务即可。 但是，这样有很多问题。 如果遇到明显的bug，只能在本地修改，无法对原主题仓库进行贡献。 原主题仓库更新后，本地无法通过git快捷的更新。 使用git submodule git对于子模块的管理有如下几个关键点。 首先，.git目录中会有一个modules目录，里面记录了所有子模块的版本控制信息。 其次，在主仓库下，会创建一个.gitmodules文件，里面以条目的形式记录了子仓库名称，本地相对地址，以及远程仓库地址。 最后，git会生成一个非常特殊的文件，他的文件模式是160000，与一般的100644文件不同。它在windows的资源管理器下并不可见。他被用于覆盖子模块真实的目录内容，仅仅以子模块的当前所在记录的hash值，存入该文件来代替。每当子模块更新，该文件也会更新。 创建流程是： 1234567# 如果是第一次创建子模块，则项目中会出现两个新文件：.gitmodules和以relative-path为名的特殊文件。同时，该命令会将子模块克隆到本地的relative-path目录下。$ git submodule add &lt;url(https://github.com/username/submodule-repo.git)&gt; &lt;relative-path&gt;# 在主仓库，将更改提交并push到远程$ git add --all$ git commit -m &lt;msg&gt;$ git push origin master 此时，在主仓库中，relative-path对应的地方会出现一个链接，点击可以跳转到子模块的仓库。 这就意味着，主仓库是没有子仓库的内容的，只保留了一个链接。 想要获得子模块的内容，需要在workflow file里面加入新的CI任务。 12345# 注意，该任务需要放在build之前name: Fetch submodulerun: | git submodule sync git submodule update --init --recursive 一般情况下，主仓库会获得子仓库的内容，并根据子仓库的内容build博客。 权限问题 如果使用了ssh的仓库地址，则可能会出现权限问题。 由于我的子仓库是公有仓库，所以简单的解决办法是，使用https的仓库地址。 与github actions/checkout@v3集成 github仓库服务器每次运行CI/CD任务，其实都需要将主仓库克隆到本地。这是通过复用actions/checkout@v3实现的。而该action同时提供了对子模块的支持。只需要进行如下配置即可。 1234- name: Checkout uses: actions/checkout@v3 with: submodules: true 该配置还能自动在没有提供ssh-key的情况下，将.gitmodules中由ssh协议指定的url转换成https来使用。","link":"git%E2%80%94%E2%80%94%E4%BA%BA%E7%B1%BB%E5%A5%BD%E6%9C%8B%E5%8F%8B/"},{"title":"docker在WSL2环境中的代理问题","text":"事情的起因 是，电脑最近重装了系统之后，docker一直还没安装，最近做毕设正好有需求，再加上久闻docker大名，想要成为docker糕手😍 但是，如果你： 人在中国 使用windows系统下的docker desktop 使用WSL2而不是WSL1 那么恭喜你，你将喜提一个超~~级难debug的bug（好像是最近一个新的bug，仓库里有人发了关于这个问题的issue 如何复现这个bug 默认情况下，WSL2会在windows的用户目录（一般是C:/Users//）下创建一个隐藏的.wslconfig文件，这个文件中，有一个设置networkingMode，默认情况下可能是这样的： .wslconfig1networkingMode=mirrored 这个配置如果不填，则会使用NAT模式 如果是mirrored模式，那么docker无法找到正确的主机代理 此时，如果你想运行docker pull xxx命令，就会出现类似于下面的bug bash1Error response from daemon: Get &quot;https://registry-1.docker.io/v2/&quot;: proxyconnect tcp: dial tcp 127.0.0.1:7890: connect: connection refused 我尝试过的方法有： 打开clash的系统代理，并重启docker--&gt;😢 修改docker desktop界面的Settings-&gt;Resources-&gt;Proxies，在这里打开Manual proxy configuration，并将http和https的代理都设置为http://127.0.0.1:7890（7890是clash的默认端口）--&gt;😢 Settings-&gt;Docker Engine，在右侧编辑框里加入下面的规则： docker engine12345678{ &quot;xxx&quot;: {}, &quot;yyy&quot;: &quot;zzz&quot;, &quot;proxies&quot;: [ &quot;httpProxy&quot;: &quot;http://127.0.0.1:7890&quot;, &quot;httpsProxy&quot;: &quot;http://127.0.0.1:7890&quot; ]} 然后重启docker--&gt;😢 使用clash的TUN模式--&gt;😢 以及上述各种方式的排列组合--&gt;😢😢😢😢 但是其实解决方法就是，把networkingMode这一行的配置删了就行 原理不太懂，但是感觉是mirrored模式下，docker的代码写死了一定会使用127.0.0.1:7890这个代理，但是WSL2环境中，127.0.0.1也就是localhost所代表的回环地址，已经不像WSL1中那样表示windows主机了，而是指的虚拟机自身的虚拟网卡，所以无法访问到主机的代理设置 话说中国docker 哎，听说是2024年年中六七月的时候，高层强行封禁了docker hub的内地访问，并且关停了很多国内的镜像源 不过，这个镜像源再禁，也总有漏网之鱼。另外，都用docker了，肯定至少有些计算机和编程基础，那还可能不知道怎么科学上网么（ 所以就想着，与其找一个可能随时就会再次被封的国内镜像源，还不如直接访问docker hub 总之 不要盲目怀疑自己，路见不平一声吼，github找issue！","link":"docker%E5%9C%A8wsl2%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86%E9%97%AE%E9%A2%98/"},{"title":"配置hexo博客，并更换多种主题","text":"hexo 博客的基本维护方式 搭建过程可参考hexo 博客搭建教程。 hexo 提供了便捷的构建、部署功能。在本地添加了新的 markdown 日志或者图片之后，只需执行如下代码： 123456# 清除已有的构建目录，默认为publichexo clean# 构建新的静态文件，g是generate的缩写hexo g# 一条命令直接部署，d是deploy的缩写hexo d 就会把本地的 public 文件夹 push 到对应的 github 仓库，并将网站自动部署到 {github用户名}.github.io。 此外，如果想要维护本地源文件，还可以单独创建一个私有 github 仓库，用于存放 source 文件中的源文件等等。 （已弃用，请看进阶配置） 配置 hexo hexo 的默认在配置文件是根目录下的_config.yml，称之为hexo 配置文件。更改其中的属性，可以改变网页的默认文本和样式。 其中的 theme 项默认的值是 auto，我们可以更改这一个属性的值，来更换不同主题。 下载并配置主题 要更换主题，需要在hexo 主题网站选择喜欢的主题进行下载安装。 有两种方式。 第一种（所有主题均支持）：将主题对应的仓库克隆到/themes/{主题名}文件夹下。例如，对于 archer 主题，可以执行如下代码： 12# --depth=1表示，仅克隆最近一次commitgit clone https://github.com/fi3ework/hexo-theme-archer.git themes/archer --depth=1 克隆完成后，在archer文件夹的配置文件_config.yml中进行修改。 注意！每个主题的仓库中都有一个_config.yml文件，称之为主题配置文件，与根目录下的_config.yml文件是不同的。 第二种（仅部分主题支持）：通过 npm 下载主题对应的依赖包。例如，对于 keep 主题而言，可以执行如下代码： 1npm install hexo-theme-keep --save 下载完成后，themes 文件夹下不会出现对应的文件夹。若想对该主题进行配置，需要在 hexo 配置文件中，添加 theme_config 项，在 theme_config 属性后，添加主题配置属性。 配置加载原理（推测） 首先，hexo 加载根目录下的hexo 配置文件，若发现 theme 的值不为默认的 auto，则顺序进行如下过程： 对于第一种方式下载的主题： 在根目录中搜索_config.{主题名称}.yml文件，如果找到，则继续加载该配置文件中的内容，否则， 在themes文件夹中寻找主题名称对应的文件夹，如果找到，则加载themes/{主题名称}/_config.yml文件。若文件夹或者配置文件没有找到，则会报错。 对于第二种方式下载的主题： 在hexo 配置文件中寻找theme_config属性，并加载。 PS：已经证实 配置文件的优先级顺序为 根目录配置文件中的 theme_config 属性 &gt; _config.{主题}.yml &gt; 根目录配置文件 踩过的坑 首先，更改了主题名称之后，一定要清除原来的构建目录并重新构建，也就是运行 hexo clean &amp;&amp; hexo g。 不能手动在 github 的仓库设置里面添加 custom domain，因为这样每次部署后，自定义的域名都会丢失。需要在source/下创建一个CNAME的文件，将自定义域名写入。 如果添加了文件等静态资源，需要 hexo g。否则部署之后，服务器无法获得图片等静态资源文件。","link":"%E9%85%8D%E7%BD%AEhexo%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%B9%B6%E6%9B%B4%E6%8D%A2%E5%A4%9A%E7%A7%8D%E4%B8%BB%E9%A2%98/"},{"title":"inode文件系统","text":"7层架构 Block Layer 将block的序数，映射到block中实际的数据。 块大小的权衡 太小，则bitmap所需空间太大。 太大，则内部浪费可能比较严重。 File Layer 123struct inode integer block_nums[N] integer size N决定了一个文件最大有多大。 与块大小的权衡一样，N的大小也存在权衡。 解决措施：多级inode。 inode的block_nums中的元素可以指向另外一个inode，类似于多级页表。 个人理解，在block层上又封装了一层inode的原因，就是因为inode可以做多级操作，否则就和block相同了，区别仅仅是更大。 Inode Number Layer 将inode放在一张表里，这样可以通过index来访问某一inode。 File Name Layer 1234struct inode integer block_nums[N] integer size integer type // 记录inode类型，包含常规文件，目录，和符号链接等等 Path Name Layer 链接link。 可以将多个文件名映射到同一个inode。 除了.和..，不允许对目录进行链接，否则可能会出现“外存泄露”。 重命名-1 UNLINK(to_name) LINK(from_name, to_name) UNLINK(from_name) 但是这种实现有问题，当1和2之前出现了failure时，to_name没了，但是from_name还在。 重命名-2 LINK(from_name, to_name) UNLINK(from_name) Absolute Path Name Layer 根目录/。其.和..都指向/。 Symbolic Link Layer 跨存储设备。 通过文件名进行链接。 其大小指的是文件名字符串长度。 问题：如果通过symbolic link进入了一个目录，再运行cd ..，则会进入哪个目录？ 答案：会进入原目录，而不是实际目录的上层目录。 因为cd ..会被bash先解析，这是一种优化。","link":"inode%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"机器学习概论","text":"NFL定理 No Free Lunch Theorem：天下没有免费的午餐 我们计算一个学习算法\\(\\mathcal{L}_a\\)的“训练集外误差”，有 \\[ \\begin{aligned} E_{ote}(\\mathcal{L}_a|X,f)=\\sum_{h}\\sum_{x\\in\\mathcal{X}-X}P(x)\\mathbb{I}(h(x)\\ne f(x))P(h|X,\\mathcal{L}_a) \\end{aligned} \\] 如果对于所有真实目标函数\\(f\\)求和，则有 \\[ \\begin{aligned} \\sum_f E_{ote}(\\mathcal{L}_a|X,f)&amp;=\\sum_f\\sum_h\\sum_{x\\in \\mathcal{X}-X}P(x)\\mathbb{I}(h(x)\\ne f(x))P(h|X,\\mathcal{L}_a)\\\\ &amp;=\\sum_{x\\in\\mathcal{X}-X}P(x)\\sum_hP(h|X,\\mathcal{L}_a)\\sum_f\\mathbb{I}(h(x)\\ne f(x))\\\\ &amp;=\\sum_{x\\in \\mathcal{X}-X}P(x)\\sum_hP(h|X,\\mathcal{L}_a)\\frac{1}{2}2^{|\\mathcal{X}|}\\\\ &amp;=\\frac{1}{2}2^{|\\mathcal{X}|}\\sum_{x\\in \\mathcal{X}-X}P(x)\\sum_hP(h|X,\\mathcal{L}_a)\\\\ &amp;=\\frac{1}{2}2^{|\\mathcal{X}|}\\sum_{x\\in \\mathcal{X}-X}P(x)\\\\ \\end{aligned} \\] 我们可以看到，总误差与学习算法无关，也就是说，对于任意两个学习算法\\(\\mathcal{L}_a\\)，\\(\\mathcal{L}_b\\)，无论看上去\\(\\mathcal{L}_a\\)多复杂，多聪明，在期望的意义下，他们的性能是相同的。（也就是说，随便瞎猜和复杂推导一样，不学了 (*｀皿´*)ﾉ ） 尝试证明AUC计算公式 排序损失\\(\\mathcal{l}_{rank}\\)被定义为 \\[ \\begin{aligned} \\mathcal{l}_{rank} = \\frac{1}{m^+m^-}\\sum_{x^+\\in D^+}\\sum_{x^-\\in D^-}\\left(\\mathbb{I}(f(x^+)&lt;f(x^-)) + \\frac{1}{2}\\mathbb{I}(f(x^+)=f(x^-))\\right) \\end{aligned} \\] 对于一个ROC图，我们有如下关系： \\[ \\text{AUC}=1-\\mathcal{l}_{rank} \\] （代入理想模型和随机模型，发现是对的。。）","link":"%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/"},{"title":"一些画","text":"Pro Create 日期：2022-9-19 炭治郎 日期：2022-9-24 香奈乎 日期：2022-9-25","link":"%E4%B8%80%E4%BA%9B%E7%94%BB/"},{"title":"something to say","text":"For people grown up in a cross-cultural background like you, I guess it might be easier to understand why I choose neither Chinese nor Japanese but English. It is simply because to speak in a language that is not familiar to both of us helps me to confess my affection in a completely honest way. Though I've always regarded you as a little baka, I don't think it will cost so much of your brain to realize that we have been chatting nonstop for almost a week in a way that is genuinely close as I guess. During the time, it was obvious that I have shown my feelings clearly enough. It would be a big mistake if you think I talk to every girl in the way I talk to you. I've told you that to speak out those three little words or hiragana is a little bit cheesy at least for me, because there are so many more creative ways to express the romance to you. To be honest, the first time I heard your voice message, I literally felt like my heart melted. From then on, my heart melts every time I got a new voice text from you. Of course there are characters with much more adorable voice online, but I've never heard a cuter one from anyone else around me. I am pretty sure that meeting with you is the most fortunate thing that ever happened to me since my breakup 3 years ago. I didn't say \"since my birth\" because actually it is not. I'd like to just keep every word out of my mouth honest. We've talked about whether it should be considered a kind of escape to care less about whether your partner keeps being loyal to you just in order to not get hurt in the future. In my opinion, it takes nothing to pretend that it doesn't matter, but it takes courage to care. Unluckily, actually I escaped last night as well to somehow protect myself, but soon I realized it won't do any good to our relationship. Plus, I don't think to talk frankly is awkward or should be cosidered a loser. A cold war ends up in hatred, while conversations bring hope. \"You don't know me, I don't know you, so let's slow down our pace okay?\" Well I don't think so. At least for me, I know your look, your voice, your education background, even a little bit of your family and also your perspective about relationship and marriage. Not so surprisingly, you know those aspects of mine too. You can call me an honest boy, while there is also a chance that you may think I am impatient. But the fact is that I've collected everything I need to know to confirm that you are the one, so I don't want to wait for any longer. It would get me nowhere if I keep putting on a poker face in front of you to make myself look so cool to block any possible way for you to hurt me emotionally. It is just stupid. I know this letter may not be well-organized to put my thoughts together, yet it is enough for you to know everything. So, if I am the lucky guy who is deeply blessed by Lady Fortune that you have actually read till this last part, I would like you to promise me one thing, which is to buy yourself a bottle of lemon juice in that 7-11 store around your house on your way back home after you finish a day's study in some library and look up to the sky quietly for a few minutes at night. There won't be a full moon in Nagoya tonight, but I am pretty sure at the time you're watching that silver planet, there is someone else doing the same somewhere else in the world. And hopefully, it would be great if some of the fairies living beyond the clouds could carry your answer to that little boy.","link":"something-to-say/"},{"title":"前端小练习","text":"用了react的useState钩子，不过总感觉有很多赘余的部分，比如四个输入框的信息分别维护，而不是统一由一个四个元素组成的变量控制。 接下来可以尝试做一个贪吃蛇。 （已经失败了。。） 主要代码如下： react123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import { useState } from &quot;react&quot;import &quot;./App.css&quot;const InputItem = ({ handleInput, title, placeholder, error, isError }) =&gt; { return ( &lt;&gt; &lt;p className=&quot;entry-name&quot;&gt;{title}&lt;/p&gt; &lt;input className=&quot;input&quot; type=&quot;text&quot; placeholder={placeholder} onBlur={(e) =&gt; { handleInput(e.target.value, title) }} /&gt; &lt;p className=&quot;error&quot;&gt;{isError &amp;&amp; error}&lt;/p&gt; &lt;/&gt; )}export default function App() { const [username, setUsername] = useState(&quot;&quot;) const [email, setEmail] = useState(&quot;&quot;) const [password, setPassword] = useState(&quot;&quot;) const [confirm, setConfirm] = useState(&quot;&quot;) const [usernameError, setUsernameError] = useState(false) const [emailError, setEmailError] = useState(false) const [passwordError, setPasswordError] = useState(false) const [confirmError, setConfirmError] = useState(false) const handleInput = (value, title) =&gt; { if (title === &quot;Username&quot;) { if (value &amp;&amp; value.length &gt;= 3) { setUsernameError(false) setUsername(value) } else setUsernameError(true) } else if (title === &quot;Email&quot;) { const emailReg = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(\\.[a-zA-Z0-9_-])+/ if (value &amp;&amp; emailReg.test(value)) { setEmailError(false) setEmail(value) } else setEmailError(true) } else if (title === &quot;Password&quot;) { if (value &amp;&amp; value.length &gt;= 6) { setPasswordError(false) setPassword(value) } else setPasswordError(true) } else { if (value &amp;&amp; value === password) setConfirmError(false) else { setConfirmError(true) setConfirm(true) } } } const handleClick = () =&gt; { if (username === &quot;&quot;) setUsernameError(true) if (email === &quot;&quot;) setEmailError(true) if (password === &quot;&quot;) setPasswordError(true) if (confirm === &quot;&quot;) setConfirmError(true) if ( username !== &quot;&quot; &amp;&amp; !usernameError &amp;&amp; !emailError &amp;&amp; !passwordError &amp;&amp; !confirmError ) { alert(&quot;Register succeeded.&quot;) } } return ( &lt;div className=&quot;App&quot;&gt; &lt;h2 className=&quot;title&quot;&gt;Register With Us&lt;/h2&gt; &lt;InputItem handleInput={handleInput} title=&quot;Username&quot; placeholder=&quot;Enter username&quot; isError={usernameError} error=&quot;Username must be at least 3 characters&quot; /&gt; &lt;InputItem handleInput={handleInput} title=&quot;Email&quot; placeholder=&quot;Enter email&quot; isError={emailError} error=&quot;Email is not valid&quot; /&gt; &lt;InputItem handleInput={handleInput} title=&quot;Password&quot; placeholder=&quot;Enter password&quot; isError={passwordError} error=&quot;Password must be at least 6 characters&quot; /&gt; &lt;InputItem handleInput={handleInput} title=&quot;Confirm Password&quot; placeholder=&quot;Enter password again&quot; isError={confirmError} error=&quot;Passwords are not the same&quot; /&gt; &lt;button className=&quot;submit&quot; onClick={handleClick}&gt; Submit &lt;/button&gt; &lt;/div&gt; )} 目前暂时没想好怎么把这四个输入框统一管理起来。","link":"%E5%89%8D%E7%AB%AF%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"title":"台式机","text":"[TOC] 锵锵锵！我的第一台台式机！ 先上图。没学过摄影，凑合着看吧。 &lt;center&gt; &lt;img src=&quot;台式机/1.jpg&quot; alt=&quot;1&quot; style=&quot;width: 30%&quot;/&gt; &lt;img src=&quot;台式机/2.jpg&quot; alt=&quot;2&quot; style=&quot;width: 30%&quot;/&gt; &lt;img src=&quot;台式机/3.jpg&quot; alt=&quot;3&quot; style=&quot;width: 30%&quot;/&gt; &lt;/center&gt; 配置 CPU: Intel(R) Core(TM) i7-12700KF (￥1188) 主板: 微星 B760M GAMING PLUS WIFI (￥970) 内存: 32GB (阿斯加德 DDR5 6000MHz 16GB*2) (￥659) 显卡: NVIDIA GeForce GT730 (2GB 微星) (￥360) (我知道很拉...就买个300多的过渡一下，有钱了直接上5070及以上😍) 硬盘: 金士顿 SNV3S20000G (2TB 固态硬盘) (￥869) 机箱: 航嘉 S960暴风雪 白色海景房 (￥150) 散热: (￥210) CPU: 京品鹿冰封360水冷 ARGB 机箱: 京品鹿棱镜4PRO积木风扇 (正向*1 + 反向*6) 电源: 航嘉WD750 全模组 750W (￥397) 综上，不算外设，一共4803元 还有一些装机的人工费，音响，耳麦，摄像头等等是现买的，总共约500元 一些经验 小白还是别自己装了吧...容易烧主板。我就是在风冷还没到货的时候，把其他东西都装上然后通电了，然后主板和CPU就都出现了故障。当时手去摸CPU，貌似超100度... 预算吃紧的小朋友，确实可以考虑使用CPU核显或者超低价GPU过渡。不过，显卡也不要太低端了，像我这个GT730卡，驱动都装不上了，英伟达早就停止驱动维护了...本来我的需求是LOL最高画质能60帧就行，而且看到网上说这款显卡其实带得动，但是实测只能跑最低画质，还不稳定，卡的时候30帧... 其实线下买不一定更贵，反而可能比较便宜，另外线下买可以顺便让师傅指导装机，顺便装系统，最快的情况下，你可能下午去数码城，晚上回来就能玩了 编织电源模组线没啥必要感觉，几根线就两百多...(当然重度颜值党除外) ARGB的灯效还是很炫酷的，成本很低的情况下就能将主机的外观提升非常大的档次。搭配海景房，你绝对值得拥有！","link":"%E5%8F%B0%E5%BC%8F%E6%9C%BA/"},{"title":"她","text":"上色不会quq","link":"%E5%A5%B9/"},{"title":"可可的琴","text":"寒鸦戏水 等我一会儿~ 演奏者：可可同学，可爱的可 曲目：寒鸦戏水","link":"%E5%8F%AF%E5%8F%AF%E7%9A%84%E7%90%B4/"},{"title":"泉さんとの相談","text":"とっても突然ですけど、申し訳ございません。私は、泉さんに言いたいことがあるから。 一年半くらい前に、王路児さんは私の彼女になりましたのは、もうお覚えでしょうか。私たちは素晴らしい時間を過ごしました。少なくとも私はそう思いました。しかし、三ヶ月くらい前に、私たちは別かれてしまいました。 私は今までも、毎日とっても苦しんで過ごしていたんでした。毎日、いったいどうやってその人の心を取り戻せるのかとずうっと考えていました。 彼女は今、東京大学で交換留学しています。それは、泉さんはもう知っていましたかもしれません。彼女は、日本の研究環境はとても自由で楽しそうだと思いましたから、卒業した東大の修士に申し込むつもりです。 彼女は、うちの大学でいい成績を持ち、日本語は中学からずっと勉強していたからすごく上手、東大で交換留学した経験もありますから、東大の修士に合格する可能性が高いんです。 だから、復縁する思いを持っている私は、一緒に東大の修士になれるように、頑張りたいんです。だからこそ、私は今、真面目に日本語を独学したり、TOEFLに合格するために英語も勉強したりしています。 でもさあ、それはばかばかしいといわれてしまうかもしれませんね。泉さんはどう思うんですか？ずっと前から泉さんを尊敬しているので、今日はわざと泉さんのご意見を伺います。 （今、ただN３のレベルので、以上の書いた言語は間違いがたくさんありますかもしれないのは、すみません。） お久ぶりです。返事が遅れてごめんなさい。 まず、言いたいことは大体わかりました。日本語本当に上手になったね。 お二人が別れたと聞いてとても残念です。 卢くんがまだ王さんとお付き合いするために勉強を頑張っているのも立派だと思います。 でも、なぜ別かれてしまったのかは冷静に考えたほうがいいと思います。 今東京と上海は遠く、簡単には会いに行けないと思います。そのことだけが原因で別れたのなら、卢くんも東京に留学すれば、またお付き合いできると思います。 一方で、王さんは東京で勉強に集中したくて別れた可能性はありませんか？それのも別かれる前に喧嘩とかしてないですか？そのような場合、東京に来れてもまだお付き合いできるとは限りませんよね。 私は卢さんの努力をばかばかしいとは絶対に言いません。でも、一度卢くんご自身で別れるまでの経緯を振り返ってみて、今の努力が報われるか考えてみてはどうでしょうか？ ご返事してくださってすごく嬉しかったです。ありがとうございます！ 泉さんのおっしゃる通りです。問題の核心は、私たちの別れる原因です。 ちょっと複雑ですが、なるべく日本語でご説明いたします。 彼女は、私は生まれた今まで最も好きになった女の子でした。それに加えて、私はもう交通大学のようないい大学（少なくとも中国で）が合格しましたので、自分の人生はこれからきっと最高でうまくいけますと思っていたから、勉強を頑張らないようになってしまいました。頑張らなくても、未来にはきっといい仕事といい妻ができると思っていたから。まあ、もちろん今更思えば、それはとっても幼稚な考えだけでした。 それで、彼女はますます、私の向上心が足りないと思うことになります。嫌気もだんだん増えました。 それに対して、私は、彼女は私と一緒にいるのに、十分な時間を割いていないと思いますから、先に「別れよう」といいました。でも、それは本気ではなかった。私をもっと大切にしてもらうためだけの腹立たしい言葉でした。しかし、彼女は「じゃあ、そうしよう。君はこの一年に私のそばにいてくれてありがとう。もっと適した彼女が見つけるように。」といいました。 別れた後、私はどうしても彼女を忘れられなかった。 以前の自分をよく反省します。確かにその「この人生はもう最高だ」という思いはとっても幼稚なだと思います。 だからこそ、いま努力するのが始まりたいんです。でも、彼女はもう二度と私のことに好きにならないかもしれないとか、新しい男の子のことに好きになるかもしれないとかと思うと、私はすぐにすごく落ち込んでしまいます。努力する気も一瞬でなくなってしまいます。 こんなにたくさん愚痴を言って、ほんとにごめんなさい。でも、いま私はとてもつらく生きています。どうすればいいのかもよくわかりません。泉さんから、優しい言葉を言っていただきたいんです。ご迷惑をかけて申し訳ございません。 また返事遅れてすみません！木曜金曜は仕事が長引いて返事できませんでした。 なるほど、お互いの勉強への姿勢の違いがあったのなら、別れてもしょうがない気がします。 立派な大学を出れば立派な人生を送れると思ってしまう気持ちはわかります。別に怠惰だなんて思わないよ。 一方で、夢中になれる勉強があると時間がいくらあっても足りないんですよね。王さんの気持ちもわかります。 結局は二人の時間の使い方の違いでしかなくて、別れたのも仕方なかったんじゃないかと思います。 それでも卢くんが復縁したいなら、勉強を頑張るよりもお互いの価値観を理解することが大事かもしれません。お互いが勉強や仕事に夢中になったら、結局すれ違いで別れてしまうことになるかもしれませんよ？ だから、不安に思いながら勉強するくらいなら、王さんに連絡してみるのはどうでしょうか？お互い価値観の違いを知ってもお付き合いを続けられるか、話してみてはどうでしょうか？ もちろん王さんはもう彼氏がいるかもしれませんが、それで知らずに思い悩むよりはマシだと思いますよ。「案ずるより産むがやすし」です。 返事がちょっと遅れるので謝る必要が全然ありません！泉さんは優しい言葉を言ってくれて、それだけで元気づけられました。 お忙しいところで、こんなに面倒な質問をするのが、恥ずかしくてすみません。 実は、彼女に連絡することができませんからこそ、二人の周りの人を相談するんでした。 でも、彼女は日本へ出発する前に、私たちは約束しました。彼女はどうしても私と恋愛を続けたくないから、私は「じゃあ、私は君を放して、君は日本へ行こう。でもせめて、半年後に君は帰国した学校帰った時には、二人はもう一回会おうはどうでしょうか？」って言った。彼女は同意しました。 この間に、彼女は新しい彼氏ができないことを祈っていました(笑)。そして、私もこの半年くらいの時間に、もっと優れた自分をその人に見せるように、自分を変えてやる。結局はどうになるのは予想できないんですが、そうしなきゃならないんだよね。 それより、もし未来には私は本当に東京へ行ったら、ぜひ泉さんのお宅を訪ねて伺います！楽しみですね。 ちなみに、私は最近lineのアカウントができた。もしよければ、交換してもいいですか？","link":"%E6%B3%89%E3%81%95%E3%82%93%E3%81%A8%E3%81%AE%E7%9B%B8%E8%AB%87/"},{"title":"Daily Report","text":"2022-09 16 搭建了hexo个人博客。 配置了两种主题：keep和archer。 添加了以pandoc为引擎的\\(\\LaTeX\\)扩展。 两篇博客。 看了一点机器学习。 keep25分钟腿（腿已废）。 是收获满满的一天，希望自己能够坚持下来！加油！ 17 粗略看完了西瓜书第二章，发现概统中的一些概念已经忘了（比如假设检验）。 配置了博客评论gitalk。 修复了about页没有intro-image的bug（是因为about文件夹中的index.md没有加layout的front matter）。 添加了404页（May the force be with you :)）。 更新了about页~。 18 对archer版权信息框和gitalk默认样式进行了微调，主要包括： 取消了版权内容的条状下边框，对应themes\\archer\\src\\scss\\_partial\\_post-page.scss。 对版权日期显示格式进行了规范，对应themes\\archer\\layout\\post.ejs 添加评论显示框的圆角，对应source\\gitalk.css。 取消了评论显示区的hover特效，对应source\\gitalk.css。 修改了在暗黑模式下，gitalk元信息区action按钮、version文本、编辑区、预览区、评论展示区的前景色，对应themes\\archer\\src\\scss\\_dark\\_partial\\_comment\\_gitalk-dark.scss。 配置了algolia搜索引擎，并配置了其自动更新索引的github工作流，并修复了pandoc依赖缺失的问题。参考这一篇知乎。 提交了我的第一个github pull request，尝试修复archer主题的一个小bug，即上面提到的1.5。已成功被merge，解锁了github成就！😍 对博客仓库结构进行了调整。 改用了另外的图床。 在博客相邻的标题间，添加了&lt;br&gt;。 学习了很多github CI/CD的知识，包括github actions的workflow file怎么写，这个是真的恶心。😢 19 应用体系架构作业一第一部分，虽然还要再修改一下。 开始Pro Create！处女作。 20 博客首页摘要格式化功能开启。 博客图片圆角。 asa作业一第一题完成。 keep20分钟核心。 21 阅读《月亮与六便士》，至75%。 修复了index页摘要标题行距bug。 对于过日子来说，今天是碌碌无为的；可是，我它用来放飞了灵魂。 22 读完《月亮与六便士》，并撰写了读后感。 那封信。 开始阅读《苏东坡传》。 配置了cse lab1环境。 23 修复了sidebar时间显示NaN/aN/aN的问题，原因是hexo配置文件中jsonContent字段的date设置为了false。 自定义摘要长度，方法为在hexo配置文件中添加excerpt字段，并调节depth。 修改了主页每页博客数量，目前为5。 《苏东坡传》，20%。 keep27分钟臀腿+核心。 24 炭治郎临摹（其实是像素级抄袭~）。 蝴蝶忍正在上色。 《苏东坡传》，30%。 今天是纯纯不务正业的一天啊哈哈哈~~。 25 香奈乎完工。 应用体系架构（后面就简称app吧）作业一完成，将遇到的坑总结在了新博客。 启用了博客的mermaid图表功能。 26 控线练习3页。 27 心理咨询。 控线练习1页。 跑步3.08km，用时16'17''。 28 跑步3.06km，用时14'55''。 29 编译原理lab2完成。 控线练习1页。 《苏东坡传》40%。 博客公私仓库分离。 跑步3.02km，用时14'21''。 30 起草第二封信。 《苏传》50%。 跑步3.00km，用时14'46''。 2022-10 1 和琛琛打网球1h。 跑步3.03km，用时13'43''。 与国同庆，今天给自己放个小假~。 2 cse lab1 part1A完成。 跑步3.03km，用时14'16''。 3 cse lab1 part1B完成。 好久不去ktv了，唱了很多日语歌，至少彼时彼刻，很开心。 4 cse lab1 part1CD完成。 5 白色相簿2ic50%。 6 白色相簿2ic完成。 好的作品，跨越爱好，跨越年代。还是小看了二次元的精神丰富度。 7 cse-lab1 part2ABC完成（虽然放弃了part2D的symlink）。 《苏传》60%。 8 app作业二完成。 推了一会wa2的cc。 9 compiler复习，lab3环境准备。 《苏传》70%。 10 白2大三圣诞节。 和巢老师谈话。 11 白2cc雪菜线完结。 12 ML作业1。 13 音频上传。 14 算法作业1完成。 2.03km，10'28''。 15 复习了ICS第七章。 一个github issue，问题是post中表格头显示异常（已被解决）。 3.17km，16'07''。 16 复习了ICS第八章。 两个PR，均已被merge。 提出关于archer TOC的issue，已被响应（甩锅）。 博客和archer仓库重构。 2.01km，12'03''。 尝试了在blog主仓库，添加archer作为子模块。期望达到的目标为：在日常更新主仓库的博客等内容时，可以同时对archer进行贡献或者个性化修改。archer的目录需要暴露给blog，因为blog需要用到archer中的文件进行页面渲染。有待探索。 17 放弃github CI/CD，改用本地构建然后直接部署到public repo。原因有两个： 如果通过push到私有仓库，在远端构建并部署，则需要下载pandoc等依赖，比较复杂。 actions/checkout@v3会将source的内容克隆到服务器上，但是克隆会覆盖文件的修改时间，导致博客页面上的所有博客的修改时间均为克隆时间，而git又没有提供解决办法。 顺便写了个脚本go.bat，一步到位~。 顺便解决了时区的问题。因为是本地构建，所以时间正常显示。 学习了git submodule的使用方法，解决了昨天的遗留问题。总结在了这篇博客中。 18 复习了ICS第九章。 复习了compiler关于parser的部分，编写了部分lab3代码。 3.09km，15'45''。 写了一点点mine主题。 19 更新了about页，因为突然想起来，VG100的项目也可以列进去~🤗。 改了改日记里面对博客的引用，因为前几天改了permalink的格式。 连追八集边缘行者😍。 3.04km，12'53''。 compiler lab3第一版（虽然一直syntax error）。 20 3.15km，15'19''。 21 看医生。 研究了ipads面试论文，基本搞懂了机器学习辅助缓存的基本原理。 22 ipads面试，自我感觉一般quq。 完成了compiler的lab3。 修补了cse lab1 2d部分未完成的任务，同时将代码迁移到wsl上，避免后续挂载问题。 3.53km，18'55''。 23 散步\\(n\\)圈（\\(n\\ge8\\)）。由于一直在聊天所以实在不记得了hhh。 小法绝活练成（bushi）。另外，大概可能要开始写信了呀。 24 第二封信。 25 学长碎碎念。 26 yh碎碎念，甚至帮做ppt了hhh。 27 af碎碎念。 这几天只剩下碎碎念了。。。 28 aea作业4完成。 理清了一些关于摘要，签名，证书的原理。 29 完成cse lab2A part1 part2。 直系学长东工大留学经验分享。听完感觉又有点信心了hh。 30 完成cse lab2A part3。 完成算法作业2。 31 复习了compiler type checking，开工lab4。 综合日语第二次，16课朗读+词汇背诵。 2022-11 1 完成了大部分compiler lab4。 2 完成了lab4。 复习compiler，因为明天要考试了quq。 3 compiler考试，发挥正常。 看医生。 4 《明朝那些事儿（一）——洪武大帝》10%。 JLPT N1-N5的例题全都挑战了一遍，发现自己目前大概在N4-N3之间的水平。不过，利用中国人的汉语和英语加成，N2的读解文章也能大概看懂，需要更多练习听解。 试做了2011.12 N3真题，刨除尺度计分的因素，综合得分大概135分左右，超过了95分的及格线。已复盘。 5 2011.07 N3，刨除尺度计分，146。已复盘。 JLPTというアプリで単語を70個覚えました。 6 新しい単語を７０（N2）＋１２０（N5）個覚えました。前に覚えた単語を７０個を復習した。 2012.07 N3，言语部分-11分，读解-8分。 简单了解了fair division和stable match的问题，准备周三与陶老师见面。 7 新しい単語７０個。７０個を復習した。 8 新しい単語７０個。７０個を復習した。 陶老师的论文浅读。 9 和陶老师进行了交流，基本介绍了研究方向和问题。 新しい単語７０個。７０個を復習した。 10 泉さんとご相談をしました。 新しい単語３５個。７０個を復習した。 cse lab2B完成。 ML hw2完成。 飛くんとジョギングをした。 11 ML lab1完成。 新しい単語３５個。３５個を復習した。 2012.07 N3 听解-17分，总分144。复盘了言语，读解和部分听解。 飛くんとジョギングをした。 12 完成了algorithm assignment3。尝试学习tikz画图论用图，但是失败了。。 JLPTでN3の模擬試験は参加しました。得点はまだ出ていない。でも、聴解問題はちょっと難しかったな。 新しい単語３５個。 13 Talked with Aysu. 単語３５個。 复习了cse部分知识。明天还要继续，否则后天寄了哇。。 今天外卖能送到楼下了，本学期第一次在楼下取到外卖，有点怀念了😭。 14 复习了cse，包括乐观并发控制，事务原子控制，谷歌文件系统，inode-based文件系统等等。 単語３５個。 今天连翘了三节课复习，结果晚上陈老师来问问题还是不会，哎，希望明天加油吧。。 15 cse期中考，感觉发挥非常不好。 単語７０個。 2012.12 N3 言语-10，语法-4，听力-2，总分164！头一次上160hh。 复习了一点compiler activation record内容。 16 単語３５個。 2023-06 27 完成了一个较为美观的表单组件。 28 遇到一个坑，那就是css的transition属性中，涉及时间一定要加单位，否则会被视为无效。 29 react的根节点默认被StrictMode包裹，不去掉的话，在开发时，会有多次重复渲染。 当Array的内容是undefined时，使用map不会进行转换。 用react函数式组件写了一半的贪吃蛇，太难了，发现只是有很多漏洞。 2023-07 1 弃用了archer主题（由于一些bug），找到并使用了一个更加漂亮的主题icarus，还有一些进阶配置尚未完成。 2 重读了react官方文档，发现他们已经全面迁移到函数式组件了。 学习了一点next.js框架，是为了给react做路由的。 学习了一点go。 2023-08 1 leetcode 4，寻找两个数组中第k小的值，经典算法。 2 leetcode 6-14，大部分是简单中等难度题。 复习归并排序。 25 leetcode到37，前几天忘了记录。","link":"daily-report/"},{"title":"柯柯的画","text":"阿贝多 玩原神的时候被阿贝多的美貌感动到了，想当阿贝多的狗😍 作者：柯柯，软院小仙男 人物：阿贝多——原神","link":"%E6%9F%AF%E6%9F%AF%E7%9A%84%E7%94%BB/"},{"title":"欢迎来到我的博客！","text":"这是我的第一篇博客 以后会经常在这里记录一些我的学习经历 包括各种技术的踩坑之旅 加油 頑張って！❤","link":"%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%81/"},{"title":"求职模板","text":"简历 个人信息 姓名：卢天宇 性别：男 年龄：23 邮箱：384668412@qq.com 工作及教育经历 2019.09-2025.06 上海交通大学 软件工程专业本科生 2021.07-2021.09 上海那一科技有限公司 前端开发实习生 专业技能 熟练使用C++，了解Java，python等编程语言 掌握基础数据结构和算法 项目经历 LSM键值存储系统 获奖经历 2019.12：密西根学院自设奖学金——吴炯孙洁阳光奖学金，额度10,000元 2021.01：入选上海交通大学致远工科荣誉计划 2021.12：致远励志奖学金，额度5,000元 2022.03：电子信息与电气工程学院B类奖学金，额度1,000元 2022.12：致远励志奖学金，额度5,000元 2022.12：电子信息与电气工程学院C类奖学金，额度500元 2023.12：致远励志奖学金，额度5000元 个人账号 个人博客：https://lulu010722.com github：https://github.com/lulu010722","link":"%E6%B1%82%E8%81%8C%E6%A8%A1%E6%9D%BF/"},{"title":"《月亮与六便士》","text":"满地都是六便士，他却抬头看见了月亮。 其实，上面这句话，并非出自原书。起初是对毛姆的《人性的弱点》的匿名评论，被刘瑜概括成了这句话。毛姆很喜欢月亮和六便士的比喻，便以此为题，开始进行他下一篇长篇小说的创作。 思特里克兰德是一个极为勇敢的天才，同时也是一个人性的罪犯。 故事开篇，他已然是一个小有成就的股票经纪人，有一个漂亮贤惠的妻子，和一对健康活泼的儿女。但是，一个人的处境越安逸，越稳定，想要跳出这种枷锁，便越需要非凡的勇气。当思特里克兰德决定去往巴黎，再也不回来的时候，那给读者的感觉，是多种情感的复合。是费解，是好奇，是愤怒，同时也在读者心中悄然树立他非凡的形象。 他来到巴黎，本就不富裕的生活，很快就变得更加落魄。此时，施特略夫对他的帮助，是不被理解的，甚至是有违常理的。施特略夫是这本书里一个悲剧人物，笔者从他的身上看到了自己的影子。他是一个一味讨好的人，是一个无法拒绝别人的人，甚至是没有尊严的人。毛姆笔下的“我”，对它的态度是同情，而又轻蔑。 没有底线地付出自己的好，会把一个人变得低价值，而低价值的人所展现出的善良，又经常会被践踏。这是人性的弱点，有些人会下意识地慕强，对于低价值的人，他们唯恐避之不及。另一方面，只有低价值的人，才会无限制地对别人好。他无法通过自己的外在的或内在的魅力吸引他人，所以只能通过一些廉价的讨好，来维持与他人的关系，无论是爱情，友情还是社交。这些人被亲近的人用“善良“夸赞，殊不知那恰恰不是真心的善良，而是一种软弱。这听起来或许很残酷，可是，可怜之人必有可恨之处。他们在讨好别人的简单模式，和提升自己的困难模式之中，选择了前者，来维持一些肤浅的，一碰就碎的关系，可谓是舍本逐末。施特略夫惹人同情，可是，对于他自己的悲剧，我认为他不无责任。他那近乎无耻的善意，虽然拯救了思特里克兰德的生命，但是仍然遭人唾弃，这就是人性。 害死了布兰特，伤透了施特略夫，在被问及，“你是否对这些事，曾经抱有过一点内疚的情感？”时，思特里克兰德的回答是，“我为什么要内疚？”他丝毫不受影响，即使他的身上，已经搭上了一条人命。他的冷漠深入骨髓，任何道德或伦理，在他这里无法奏效。他作为一个人，是一个道德的罪犯，然而他确实是一个真正自由的人。 他在马赛的生活我认为可以忽略，仅仅以艰难困苦代替即可。 在塔希提岛，他真正找到了自己一直寻找的心灵归处。他找到了一个真正爱他的女人，他又有了几个孩子，虽然这些对他而言，轻如鸿毛。他开始在山中一间偏僻又简陋的屋子里，开始自己的创作。上帝首先是夺走了他的眼睛，然而这无法阻止他沉浸在那个涂满壁画的屋子里，直到他被夺去了生命，连同他那惊世骇俗的壁画屋一起。 多看了几篇他人的书评，仔细琢磨了书中的次要人物，也有新发现。 思特里克兰德太太是一个精明有城府的人，他善于伪装自己，即使她的丈夫早已抛弃他二十余年，她还是对外人维持着一种平安无事的假象。书中有这样一段话： 在她破碎的心中，爱情受辱的苦闷是否掺杂着虚荣心受损的痛苦，这在年轻的我看来是肮脏的，这种怀疑令我不安。 她的悲伤是不单纯的，其中怀有对社会地位丧失，对自身颜面扫地的虚荣。 而布兰特，她没有选择，幼年遭遇使她没有办法拒绝当时的施特略夫，从而嫁给了一个她不爱的男人。当听说丈夫要带思特里克兰德回家养病，她的恐惧，也许是害怕自己真的会压抑不住性的呼唤，做出有悖伦理的事。这在当时的英国社会，是饱受唾弃的。 本想补充些什么，终于想不出，便放些名句摘抄不妨。 她这么说毫无贬低之意，反倒充满深情，她好像希望通过承认他最差的一面，来保护他免受朋友诽谤。 愤怒的道德没有足够的力量对罪人直接加以惩罚，这总是令人痛心的。 我不知真诚中有多少伪装，高贵中有多少卑鄙，邪恶中有多少善良。 一个人掉进水里，游泳游得好坏都无关紧要，他必须出去，否则就会淹死。 只有诗人或圣徒才会自信地期望，浇灌沥青路面，百合花会回报他的辛劳。 当人们说他们不在乎别人怎么看他们时，他们多半是在欺骗自己。 当你的非常规只是你那个群体的常规时，做到世人眼中的非常规并不难。 她很精明地意识到，你老是诉说不幸，人们很快就会厌倦，而且不愿看到你的惨样。 女人经常为了爱情寻短见，但一般来说，她们会很小心，不会让自杀成功。 女人可以原谅他对她造成的伤害，却永远无法原谅他为她做出的牺牲。 自命不凡只会暴露他的思想贫乏。涂了油漆貌似铁板的木条看上去也只是木条。","link":"%E3%80%8A%E6%9C%88%E4%BA%AE%E4%B8%8E%E5%85%AD%E4%BE%BF%E5%A3%AB%E3%80%8B/"},{"title":"《苏东坡传》","text":"莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。 料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。 走进林语堂先生的《苏东坡传》，东坡正传没见几句，倒是看了不少苏家长辈的趣事，还有三苏二次赴京上任途中的三峡奇景。林语堂先生的语言通俗易懂，偶尔诙谐幽默。例如，今日读到，苏洵青年时期不爱读书。直至27岁，看到自己的哥哥，内兄，还有两个姐丈，都已科考成功，行将做官为吏，顿时追悔韶光虚掷，痛自鞭策。对此，他这样写到： 大人常举这件事来鼓励年轻人，告以只要勤勉奋发，终会成功的。当然，聪明的孩子也许会推演出相反的结论，那就是孩童之时不一定非要专心向学。 又有另一处。书中讲到，古时行经三峡的人，往往在进入三峡之前焚香祷告，出了三峡再焚香谢神。于是： 不管他们上行下行，在三峡危险的地方，神祇准保有美酒牛肉大快朵颐。 多日未曾开卷，今天可终于是把苏东坡人生中最重要的一段政治经历——王安石变法——看完了。 诚如一众读者所感，我也觉得，在《苏传》中，他对于王安石的描摹未免有失偏颇。在这本书中，王安石被刻画成了一个颠倒黑白，混淆是非，党同伐异，欺君罔上的小人。自“王安石变法”至“人的恶行”凡三章，或明指王安石改革制度危害之深重，或暗喻王安石个人品行之败坏，不一而足。 虽未尝研读王安石的经史著作，亦不曾考究其变法内容的实际影响，可单单由王安石之被列入“唐宋八大家”一事便可知，他本人想必并不像林语堂笔下所写一般卑劣。林语堂受西方经济社会制度的影响，对王安石变法所代表的国家资本主义思想深恶痛绝，再加上此书又是为苏轼著书立说，于是在个人情感的影响下，将王安石描述的过于负面，有失公正，不够客观。 受此时局动荡之影响，苏东坡很难自保。他一向是坦率直言，为人最忌阳奉阴违。他对新政的看法基本中立，对王安石的变法内容不全盘否定，但也并不欣然接受，于是他在朝中，自然在两派中都无法交好。 熙宁四年（1071），苏轼来到杭州，他的第二故乡。对于杭州人来说，他们是不喜欢承认苏东坡生于眉州的，原文如下： 今天，去此伟大诗人居住于杭州，歌咏于杭州，已经一千余年，在你泛舟于西湖之上，或攀登上孤山岛或凤凰山上，或品茗于湖滨酒馆中，你会听到杭州本地的主任嘴边常挂着“苏东坡，苏东坡”。你若指出苏东坡是四川人，他会不高兴听。他心里认为苏东坡生于杭州，除去到京都之外，何尝离开过杭州！ 在杭州，他常与僧侣为伴，亦频频为歌伎题诗。 书中记载了一则东坡与好友佛印的趣事。“鸟”字在中国俚语中有不雅之意，苏东坡借此字想要开佛印的玩笑。他说，“古代诗人常常将‘僧’和‘鸟’在诗中相对，例如‘鸟宿池边树，僧敲月下门’，又如‘时闻啄木鸟，疑是叩门僧’。我佩服古人以‘僧’对‘鸟’的聪慧。” 佛印的回应如下： 这就是我为什么以“僧”的身份与你相对而坐的理由了。（暗指苏东坡为“鸟”） 在北宋，文人雅士为官之时，在酒宴场合，与官妓相调戏并以诗相赠，是被接受的。东坡以其天妒之才，为各路名妓题赠了不少诗词。但纵然苏轼爱出席此等酒筵征逐，他并不沉迷声色。他的所爱，在杭州的山水之间，尤以西湖为最。他对西湖的情感，饱含在如下这首广为流传的诗中： 水光潋滟晴方好，山色空蒙雨亦奇。 欲把西湖比西子，淡妆浓抹总相宜。 当然，在杭州，与苏轼相伴的并不只有诗酒与山河。当时安石还没有被罢相，新政仍在实施。其为害之烈，一一体现在杭州的民生上。除去“荡气回肠的爱情诗，启人灵思的山水诗”，苏轼在杭州期间，也曾写下了大量“戏谑讽刺的抗暴诗”。 熙宁七年，苏轼转调密州（今山东诸城市，是潍坊的下辖县，与青岛毗邻）知州。因为弟弟子由在山东济州任职，于是苏东坡变在杭州任期届满之时，呈请调任到山东去。“这是苏东坡最难过、最沮丧的一段时光。”但是，他的诗才在这一时期，达到完全成熟的地步。“愤怒与苛酷的火气已无，只剩下安详平和与顺时知命的心境。” 熙宁九年，苏轼又被改派至徐州。在任期内，为治理黄河水患，而加强城基，增加城高。治水成功后，由于苏轼喜欢建筑，便在外围城墙上，修筑了一座楼，楼高百尺，谓之“黄楼”。后来，苏东坡在徐州任期内所作的诗歌总集，便以“黄楼”命名，正如在密州时，他曾建“超然台”，此台也成了苏东坡在密州时所写诗集的名称。 尚未读完，暂无定论。 不妨先放些摘抄。 诗词 十年生死两茫茫，不思量，自难忘。千里孤坟，无处话凄凉。纵使相逢应不识，尘满面，鬓如霜。 夜来幽梦忽还乡，小轩窗，正梳妆。相顾无言，惟有泪千行。聊得年年断肠处，明月夜，短松岗。 ——《江城子·乙卯正月二十日夜记梦》 此为东坡为悼念亡妻王弗而创作的悼亡词。 东风知我欲山行，吹断檐间积雨声。 岭上晴云披絮帽，树头初日挂铜钲。 劝君莫惜金缕衣，劝君惜取少年时。 花开堪折直须折，莫待无花空折枝。 林语堂原文 使文学作品有别于一般作品，就在于在精神上取悦于人的声韵、感情、风格而已。 对国运为害之烈，再没有如庸妄之辈大权在握、独断独行时之甚得了。 所谓华美靡丽的风格，可以说就是堆砌艰深难解之辞藻与晦涩罕见的典故，以求文章之美。在此等文章里，很难找到一两行质朴自然的句子。最忌讳指物直称其名，最怕句子质朴无华。苏东坡称这种炫耀浮华的文章里构句用字各自为政，置全篇效果于不顾，如演戏之开场日，项臂各挂华丽珠宝的老妪一样。 读苏东坡来信，不知为何，我竟喜极汗下。老夫当退让此人，使之出人头地。 ——欧阳修 苏东坡这时轻松愉快，壮志凌云，才气纵横而不可抑制，一时骅骝长嘶，奋蹄蹴地，有随风飞驰、征服四野八荒之势。 在历史上，多少政治的罪恶都是假借“人民”的名义而犯下的，现代的读者自然不难明白。","link":"%E3%80%8A%E8%8B%8F%E4%B8%9C%E5%9D%A1%E4%BC%A0%E3%80%8B/"},{"title":"雷电将军","text":"","link":"%E9%9B%B7%E7%94%B5%E5%B0%86%E5%86%9B/"}],"tags":[{"name":"mysql","slug":"mysql","link":"tags/mysql/"},{"name":"踩坑","slug":"踩坑","link":"tags/%E8%B8%A9%E5%9D%91/"},{"name":"git","slug":"git","link":"tags/git/"},{"name":"cse","slug":"cse","link":"tags/cse/"},{"name":"机器学习","slug":"机器学习","link":"tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"前端","slug":"前端","link":"tags/%E5%89%8D%E7%AB%AF/"}],"categories":[{"name":"课程","slug":"课程","link":"categories/%E8%AF%BE%E7%A8%8B/"},{"name":"配置","slug":"配置","link":"categories/%E9%85%8D%E7%BD%AE/"},{"name":"教程","slug":"教程","link":"categories/%E6%95%99%E7%A8%8B/"},{"name":"hexo","slug":"教程/hexo","link":"categories/%E6%95%99%E7%A8%8B/hexo/"},{"name":"git","slug":"教程/git","link":"categories/%E6%95%99%E7%A8%8B/git/"},{"name":"展厅","slug":"展厅","link":"categories/%E5%B1%95%E5%8E%85/"},{"name":"她们","slug":"她们","link":"categories/%E5%A5%B9%E4%BB%AC/"},{"name":"docker","slug":"教程/docker","link":"categories/%E6%95%99%E7%A8%8B/docker/"},{"name":"开发","slug":"开发","link":"categories/%E5%BC%80%E5%8F%91/"},{"name":"日语","slug":"日语","link":"categories/%E6%97%A5%E8%AF%AD/"},{"name":"日记","slug":"日记","link":"categories/%E6%97%A5%E8%AE%B0/"},{"name":"书架","slug":"书架","link":"categories/%E4%B9%A6%E6%9E%B6/"}],"pages":[{"title":"关于我","text":"冰化了还有棍儿 坐标：上交，软工，大三 语言： C++ Java JavaScript MySQL 框架： React React Native SpringBoot Hibernate （2024更：以上几乎都忘了quq） 码龄：两年 偶像：那必须是陈奕迅 爱好：日语和网球，当然还有业余0.1级的钢琴（いつも何度でも——千与千寻主题曲） 实习经历： 2021.07-2021.09：于上海那一科技有限公司担任前端开发实习生，主要使用React和TypeScript编写web网页。同时负责撰写技术文档，包括软件著作权文档，专利申请书等等。 在校荣誉： 2019.12：密西根学院自设奖学金——吴炯孙洁阳光奖学金，额度10,000元 2021.01：入选上海交通大学致远工科荣誉计划 2021.12：致远励志奖学金，额度5,000元 2022.03：电子信息与电气工程学院B类奖学金，额度1,000元 2022.12：致远励志奖学金，额度5,000元 2022.12：电子信息与电气工程学院C类奖学金，额度500元 2023.12：致远励志奖学金，额度5,000元 项目经验： VG100课程项目，静态网页游戏：打砖块，Calypso。 LSM键值存储系统。 当潮流爱新鲜 当旁人爱标签 幸得伴着你我 是窝心的自然 当闲言再尖酸 给他妒忌多点 因世上的至爱 是不计较条件 谁又可清楚看见 ——《无条件》陈奕迅","link":"about/index.html"},{"title":"[404]","text":"","link":"404.html"},{"title":"tags","text":"","link":"tags/index.html"},{"title":"categories","text":"","link":"categories/index.html"}]}